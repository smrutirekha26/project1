
intrupt_uart_led.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00000f2c  00000000  00000000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .relocate     000000d8  20000000  00000f2c  00020000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          0000015c  200000d8  00001004  000200d8  2**2
                  ALLOC
  3 .stack        00002004  20000234  00001160  000200d8  2**0
                  ALLOC
  4 .ARM.attributes 00000028  00000000  00000000  000200d8  2**0
                  CONTENTS, READONLY
  5 .comment      00000059  00000000  00000000  00020100  2**0
                  CONTENTS, READONLY
  6 .debug_info   00017231  00000000  00000000  00020159  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00002461  00000000  00000000  0003738a  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_loc    0000abb8  00000000  00000000  000397eb  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 000008a0  00000000  00000000  000443a3  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_ranges 00000e18  00000000  00000000  00044c43  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_macro  0001cf9a  00000000  00000000  00045a5b  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_line   0000ed8d  00000000  00000000  000629f5  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_str    00096ed7  00000000  00000000  00071782  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_frame  00001644  00000000  00000000  0010865c  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <exception_table>:
   0:	38 22 00 20 2d 01 00 00 29 01 00 00 29 01 00 00     8". -...)...)...
	...
  2c:	29 01 00 00 00 00 00 00 00 00 00 00 29 01 00 00     )...........)...
  3c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
  4c:	ed 08 00 00 29 01 00 00 29 01 00 00 29 01 00 00     ....)...)...)...
  5c:	29 01 00 00 29 01 00 00 11 0c 00 00 29 01 00 00     )...).......)...
  6c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
  7c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
  8c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
  9c:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...
  ac:	29 01 00 00 29 01 00 00 29 01 00 00 29 01 00 00     )...)...)...)...

000000bc <__do_global_dtors_aux>:
  bc:	b510      	push	{r4, lr}
  be:	4c06      	ldr	r4, [pc, #24]	; (d8 <__do_global_dtors_aux+0x1c>)
  c0:	7823      	ldrb	r3, [r4, #0]
  c2:	2b00      	cmp	r3, #0
  c4:	d107      	bne.n	d6 <__do_global_dtors_aux+0x1a>
  c6:	4b05      	ldr	r3, [pc, #20]	; (dc <__do_global_dtors_aux+0x20>)
  c8:	2b00      	cmp	r3, #0
  ca:	d002      	beq.n	d2 <__do_global_dtors_aux+0x16>
  cc:	4804      	ldr	r0, [pc, #16]	; (e0 <__do_global_dtors_aux+0x24>)
  ce:	e000      	b.n	d2 <__do_global_dtors_aux+0x16>
  d0:	bf00      	nop
  d2:	2301      	movs	r3, #1
  d4:	7023      	strb	r3, [r4, #0]
  d6:	bd10      	pop	{r4, pc}
  d8:	200000d8 	.word	0x200000d8
  dc:	00000000 	.word	0x00000000
  e0:	00000f2c 	.word	0x00000f2c

000000e4 <frame_dummy>:
  e4:	4b08      	ldr	r3, [pc, #32]	; (108 <frame_dummy+0x24>)
  e6:	b510      	push	{r4, lr}
  e8:	2b00      	cmp	r3, #0
  ea:	d003      	beq.n	f4 <frame_dummy+0x10>
  ec:	4907      	ldr	r1, [pc, #28]	; (10c <frame_dummy+0x28>)
  ee:	4808      	ldr	r0, [pc, #32]	; (110 <frame_dummy+0x2c>)
  f0:	e000      	b.n	f4 <frame_dummy+0x10>
  f2:	bf00      	nop
  f4:	4807      	ldr	r0, [pc, #28]	; (114 <frame_dummy+0x30>)
  f6:	6803      	ldr	r3, [r0, #0]
  f8:	2b00      	cmp	r3, #0
  fa:	d100      	bne.n	fe <frame_dummy+0x1a>
  fc:	bd10      	pop	{r4, pc}
  fe:	4b06      	ldr	r3, [pc, #24]	; (118 <frame_dummy+0x34>)
 100:	2b00      	cmp	r3, #0
 102:	d0fb      	beq.n	fc <frame_dummy+0x18>
 104:	4798      	blx	r3
 106:	e7f9      	b.n	fc <frame_dummy+0x18>
 108:	00000000 	.word	0x00000000
 10c:	200000dc 	.word	0x200000dc
 110:	00000f2c 	.word	0x00000f2c
 114:	00000f2c 	.word	0x00000f2c
 118:	00000000 	.word	0x00000000

0000011c <atmel_start_init>:

/**
 * Initializes MCU, drivers and middleware in the project
 **/
void atmel_start_init(void)
{
 11c:	b510      	push	{r4, lr}
	system_init();
 11e:	4b01      	ldr	r3, [pc, #4]	; (124 <atmel_start_init+0x8>)
 120:	4798      	blx	r3
}
 122:	bd10      	pop	{r4, pc}
 124:	000002b9 	.word	0x000002b9

00000128 <Dummy_Handler>:

/**
 * \brief Default interrupt handler for unused IRQs.
 */
void Dummy_Handler(void)
{
 128:	e7fe      	b.n	128 <Dummy_Handler>
	...

0000012c <Reset_Handler>:
{
 12c:	b510      	push	{r4, lr}
        if (pSrc != pDest) {
 12e:	4a17      	ldr	r2, [pc, #92]	; (18c <Reset_Handler+0x60>)
 130:	4b17      	ldr	r3, [pc, #92]	; (190 <Reset_Handler+0x64>)
 132:	429a      	cmp	r2, r3
 134:	d011      	beq.n	15a <Reset_Handler+0x2e>
                for (; pDest < &_erelocate;) {
 136:	001a      	movs	r2, r3
 138:	4b16      	ldr	r3, [pc, #88]	; (194 <Reset_Handler+0x68>)
 13a:	429a      	cmp	r2, r3
 13c:	d20d      	bcs.n	15a <Reset_Handler+0x2e>
 13e:	4a16      	ldr	r2, [pc, #88]	; (198 <Reset_Handler+0x6c>)
 140:	3303      	adds	r3, #3
 142:	1a9b      	subs	r3, r3, r2
 144:	089b      	lsrs	r3, r3, #2
 146:	3301      	adds	r3, #1
 148:	009b      	lsls	r3, r3, #2
 14a:	2200      	movs	r2, #0
                        *pDest++ = *pSrc++;
 14c:	4810      	ldr	r0, [pc, #64]	; (190 <Reset_Handler+0x64>)
 14e:	490f      	ldr	r1, [pc, #60]	; (18c <Reset_Handler+0x60>)
 150:	588c      	ldr	r4, [r1, r2]
 152:	5084      	str	r4, [r0, r2]
 154:	3204      	adds	r2, #4
                for (; pDest < &_erelocate;) {
 156:	429a      	cmp	r2, r3
 158:	d1fa      	bne.n	150 <Reset_Handler+0x24>
        for (pDest = &_szero; pDest < &_ezero;) {
 15a:	4a10      	ldr	r2, [pc, #64]	; (19c <Reset_Handler+0x70>)
 15c:	4b10      	ldr	r3, [pc, #64]	; (1a0 <Reset_Handler+0x74>)
 15e:	429a      	cmp	r2, r3
 160:	d20a      	bcs.n	178 <Reset_Handler+0x4c>
 162:	43d3      	mvns	r3, r2
 164:	490e      	ldr	r1, [pc, #56]	; (1a0 <Reset_Handler+0x74>)
 166:	185b      	adds	r3, r3, r1
 168:	2103      	movs	r1, #3
 16a:	438b      	bics	r3, r1
 16c:	3304      	adds	r3, #4
 16e:	189b      	adds	r3, r3, r2
                *pDest++ = 0;
 170:	2100      	movs	r1, #0
 172:	c202      	stmia	r2!, {r1}
        for (pDest = &_szero; pDest < &_ezero;) {
 174:	4293      	cmp	r3, r2
 176:	d1fc      	bne.n	172 <Reset_Handler+0x46>
        SCB->VTOR = ((uint32_t) pSrc & SCB_VTOR_TBLOFF_Msk);
 178:	4a0a      	ldr	r2, [pc, #40]	; (1a4 <Reset_Handler+0x78>)
 17a:	21ff      	movs	r1, #255	; 0xff
 17c:	4b0a      	ldr	r3, [pc, #40]	; (1a8 <Reset_Handler+0x7c>)
 17e:	438b      	bics	r3, r1
 180:	6093      	str	r3, [r2, #8]
        __libc_init_array();
 182:	4b0a      	ldr	r3, [pc, #40]	; (1ac <Reset_Handler+0x80>)
 184:	4798      	blx	r3
        main();
 186:	4b0a      	ldr	r3, [pc, #40]	; (1b0 <Reset_Handler+0x84>)
 188:	4798      	blx	r3
 18a:	e7fe      	b.n	18a <Reset_Handler+0x5e>
 18c:	00000f2c 	.word	0x00000f2c
 190:	20000000 	.word	0x20000000
 194:	200000d8 	.word	0x200000d8
 198:	20000004 	.word	0x20000004
 19c:	200000d8 	.word	0x200000d8
 1a0:	20000234 	.word	0x20000234
 1a4:	e000ed00 	.word	0xe000ed00
 1a8:	00000000 	.word	0x00000000
 1ac:	00000e0d 	.word	0x00000e0d
 1b0:	00000d19 	.word	0x00000d19

000001b4 <EXTERNAL_IRQ_0_init>:
struct usart_async_descriptor USART_0;

static uint8_t USART_0_buffer[USART_0_BUFFER_SIZE];

void EXTERNAL_IRQ_0_init(void)
{
 1b4:	b570      	push	{r4, r5, r6, lr}
}

static inline void hri_gclk_write_PCHCTRL_reg(const void *const hw, uint8_t index, hri_gclk_pchctrl_reg_t data)
{
	GCLK_CRITICAL_SECTION_ENTER();
	((Gclk *)hw)->PCHCTRL[index].reg = data;
 1b6:	2140      	movs	r1, #64	; 0x40
 1b8:	2388      	movs	r3, #136	; 0x88
 1ba:	4a13      	ldr	r2, [pc, #76]	; (208 <EXTERNAL_IRQ_0_init+0x54>)
 1bc:	50d1      	str	r1, [r2, r3]
}

static inline void hri_mclk_set_APBAMASK_EIC_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBAMASK.reg |= MCLK_APBAMASK_EIC;
 1be:	4a13      	ldr	r2, [pc, #76]	; (20c <EXTERNAL_IRQ_0_init+0x58>)
 1c0:	6951      	ldr	r1, [r2, #20]
 1c2:	2380      	movs	r3, #128	; 0x80
 1c4:	00db      	lsls	r3, r3, #3
 1c6:	430b      	orrs	r3, r1
 1c8:	6153      	str	r3, [r2, #20]
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = ~data;
}

static inline void hri_port_clear_DIR_reg(const void *const hw, uint8_t submodule_index, hri_port_dir_reg_t mask)
{
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
 1ca:	22c0      	movs	r2, #192	; 0xc0
 1cc:	05d2      	lsls	r2, r2, #23
 1ce:	2080      	movs	r0, #128	; 0x80
 1d0:	0540      	lsls	r0, r0, #21
 1d2:	6050      	str	r0, [r2, #4]

static inline void hri_port_write_WRCONFIG_reg(const void *const hw, uint8_t submodule_index,
                                               hri_port_wrconfig_reg_t data)
{
	PORT_CRITICAL_SECTION_ENTER();
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
 1d4:	2382      	movs	r3, #130	; 0x82
 1d6:	05db      	lsls	r3, r3, #23
 1d8:	490d      	ldr	r1, [pc, #52]	; (210 <EXTERNAL_IRQ_0_init+0x5c>)
 1da:	6299      	str	r1, [r3, #40]	; 0x28
 1dc:	490d      	ldr	r1, [pc, #52]	; (214 <EXTERNAL_IRQ_0_init+0x60>)
 1de:	6299      	str	r1, [r3, #40]	; 0x28
	((Port *)hw)->Group[submodule_index].DIRCLR.reg = mask;
 1e0:	6050      	str	r0, [r2, #4]
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg |= PORT_PINCFG_PULLEN;
 1e2:	215c      	movs	r1, #92	; 0x5c
 1e4:	5c5c      	ldrb	r4, [r3, r1]
 1e6:	2504      	movs	r5, #4
 1e8:	432c      	orrs	r4, r5
 1ea:	545c      	strb	r4, [r3, r1]
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
 1ec:	6190      	str	r0, [r2, #24]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 1ee:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
 1f0:	2001      	movs	r0, #1
 1f2:	4382      	bics	r2, r0
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
 1f4:	4302      	orrs	r2, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 1f6:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
 1f8:	391e      	subs	r1, #30
 1fa:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
 1fc:	300e      	adds	r0, #14
 1fe:	4382      	bics	r2, r0
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
 200:	545a      	strb	r2, [r3, r1]
	                       // <GPIO_PULL_DOWN"> Pull-down
	                       GPIO_PULL_UP);

	gpio_set_pin_function(PA28, PINMUX_PA28A_EIC_EXTINT8);

	ext_irq_init();
 202:	4b05      	ldr	r3, [pc, #20]	; (218 <EXTERNAL_IRQ_0_init+0x64>)
 204:	4798      	blx	r3
}
 206:	bd70      	pop	{r4, r5, r6, pc}
 208:	40001c00 	.word	0x40001c00
 20c:	40000800 	.word	0x40000800
 210:	40020000 	.word	0x40020000
 214:	c0021000 	.word	0xc0021000
 218:	00000351 	.word	0x00000351

0000021c <USART_0_CLOCK_init>:
 21c:	4b06      	ldr	r3, [pc, #24]	; (238 <USART_0_CLOCK_init+0x1c>)
 21e:	2140      	movs	r1, #64	; 0x40
 220:	22cc      	movs	r2, #204	; 0xcc
 222:	5099      	str	r1, [r3, r2]
 224:	3103      	adds	r1, #3
 226:	3a04      	subs	r2, #4
 228:	5099      	str	r1, [r3, r2]
}

static inline void hri_mclk_set_APBCMASK_SERCOM0_bit(const void *const hw)
{
	MCLK_CRITICAL_SECTION_ENTER();
	((Mclk *)hw)->APBCMASK.reg |= MCLK_APBCMASK_SERCOM0;
 22a:	4a04      	ldr	r2, [pc, #16]	; (23c <USART_0_CLOCK_init+0x20>)
 22c:	69d3      	ldr	r3, [r2, #28]
 22e:	3941      	subs	r1, #65	; 0x41
 230:	430b      	orrs	r3, r1
 232:	61d3      	str	r3, [r2, #28]
{

	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_CORE, CONF_GCLK_SERCOM0_CORE_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_gclk_write_PCHCTRL_reg(GCLK, SERCOM0_GCLK_ID_SLOW, CONF_GCLK_SERCOM0_SLOW_SRC | (1 << GCLK_PCHCTRL_CHEN_Pos));
	hri_mclk_set_APBCMASK_SERCOM0_bit(MCLK);
}
 234:	4770      	bx	lr
 236:	46c0      	nop			; (mov r8, r8)
 238:	40001c00 	.word	0x40001c00
 23c:	40000800 	.word	0x40000800

00000240 <USART_0_PORT_init>:
 * \brief USART pinmux initialization function
 *
 * Set each required pin to USART functionality
 */
void USART_0_PORT_init()
{
 240:	b530      	push	{r4, r5, lr}
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 242:	2382      	movs	r3, #130	; 0x82
 244:	05db      	lsls	r3, r3, #23
 246:	2244      	movs	r2, #68	; 0x44
 248:	5c99      	ldrb	r1, [r3, r2]
	tmp &= ~PORT_PINCFG_PMUXEN;
 24a:	2501      	movs	r5, #1
 24c:	43a9      	bics	r1, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
 24e:	2401      	movs	r4, #1
 250:	4321      	orrs	r1, r4
 252:	b2c9      	uxtb	r1, r1
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 254:	5499      	strb	r1, [r3, r2]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
 256:	2032      	movs	r0, #50	; 0x32
 258:	5c19      	ldrb	r1, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXE_Msk;
 25a:	3a35      	subs	r2, #53	; 0x35
 25c:	4391      	bics	r1, r2
	tmp |= PORT_PMUX_PMUXE(data);
 25e:	3a0c      	subs	r2, #12
 260:	4311      	orrs	r1, r2
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
 262:	5419      	strb	r1, [r3, r0]
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 264:	2145      	movs	r1, #69	; 0x45
 266:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
 268:	43aa      	bics	r2, r5
	tmp |= value << PORT_PINCFG_PMUXEN_Pos;
 26a:	4322      	orrs	r2, r4
 26c:	b2d2      	uxtb	r2, r2
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 26e:	545a      	strb	r2, [r3, r1]
	tmp = ((Port *)hw)->Group[submodule_index].PMUX[index].reg;
 270:	5c1a      	ldrb	r2, [r3, r0]
	tmp &= ~PORT_PMUX_PMUXO_Msk;
 272:	3936      	subs	r1, #54	; 0x36
 274:	400a      	ands	r2, r1
	tmp |= PORT_PMUX_PMUXO(data);
 276:	3121      	adds	r1, #33	; 0x21
 278:	430a      	orrs	r2, r1
	((Port *)hw)->Group[submodule_index].PMUX[index].reg = tmp;
 27a:	541a      	strb	r2, [r3, r0]

	gpio_set_pin_function(PA04, PINMUX_PA04D_SERCOM0_PAD0);

	gpio_set_pin_function(PA05, PINMUX_PA05D_SERCOM0_PAD1);
}
 27c:	bd30      	pop	{r4, r5, pc}
	...

00000280 <USART_0_init>:
 * \brief USART initialization function
 *
 * Enables USART peripheral, clocks and initializes USART driver
 */
void USART_0_init(void)
{
 280:	b510      	push	{r4, lr}
 282:	b082      	sub	sp, #8
	USART_0_CLOCK_init();
 284:	4b06      	ldr	r3, [pc, #24]	; (2a0 <USART_0_init+0x20>)
 286:	4798      	blx	r3
	usart_async_init(&USART_0, SERCOM0, USART_0_buffer, USART_0_BUFFER_SIZE, (void *)NULL);
 288:	2300      	movs	r3, #0
 28a:	9300      	str	r3, [sp, #0]
 28c:	3310      	adds	r3, #16
 28e:	4a05      	ldr	r2, [pc, #20]	; (2a4 <USART_0_init+0x24>)
 290:	4905      	ldr	r1, [pc, #20]	; (2a8 <USART_0_init+0x28>)
 292:	4806      	ldr	r0, [pc, #24]	; (2ac <USART_0_init+0x2c>)
 294:	4c06      	ldr	r4, [pc, #24]	; (2b0 <USART_0_init+0x30>)
 296:	47a0      	blx	r4
	USART_0_PORT_init();
 298:	4b06      	ldr	r3, [pc, #24]	; (2b4 <USART_0_init+0x34>)
 29a:	4798      	blx	r3
}
 29c:	b002      	add	sp, #8
 29e:	bd10      	pop	{r4, pc}
 2a0:	0000021d 	.word	0x0000021d
 2a4:	200000f4 	.word	0x200000f4
 2a8:	42000400 	.word	0x42000400
 2ac:	200001e4 	.word	0x200001e4
 2b0:	000005a1 	.word	0x000005a1
 2b4:	00000241 	.word	0x00000241

000002b8 <system_init>:

void system_init(void)
{
 2b8:	b510      	push	{r4, lr}
 * Currently the following initialization functions are supported:
 *  - System clock initialization
 */
static inline void init_mcu(void)
{
	_init_chip();
 2ba:	4b0c      	ldr	r3, [pc, #48]	; (2ec <system_init+0x34>)
 2bc:	4798      	blx	r3
	((Port *)hw)->Group[submodule_index].OUTSET.reg = mask;
 2be:	23c0      	movs	r3, #192	; 0xc0
 2c0:	05db      	lsls	r3, r3, #23
 2c2:	2280      	movs	r2, #128	; 0x80
 2c4:	0212      	lsls	r2, r2, #8
 2c6:	619a      	str	r2, [r3, #24]
	((Port *)hw)->Group[submodule_index].DIRSET.reg = mask;
 2c8:	609a      	str	r2, [r3, #8]
	((Port *)hw)->Group[submodule_index].WRCONFIG.reg = data;
 2ca:	2382      	movs	r3, #130	; 0x82
 2cc:	05db      	lsls	r3, r3, #23
 2ce:	4a08      	ldr	r2, [pc, #32]	; (2f0 <system_init+0x38>)
 2d0:	629a      	str	r2, [r3, #40]	; 0x28
 2d2:	22c0      	movs	r2, #192	; 0xc0
 2d4:	0612      	lsls	r2, r2, #24
 2d6:	629a      	str	r2, [r3, #40]	; 0x28
	tmp = ((Port *)hw)->Group[submodule_index].PINCFG[index].reg;
 2d8:	214f      	movs	r1, #79	; 0x4f
 2da:	5c5a      	ldrb	r2, [r3, r1]
	tmp &= ~PORT_PINCFG_PMUXEN;
 2dc:	2001      	movs	r0, #1
 2de:	4382      	bics	r2, r0
	((Port *)hw)->Group[submodule_index].PINCFG[index].reg = tmp;
 2e0:	545a      	strb	r2, [r3, r1]
	// Set pin direction to output
	gpio_set_pin_direction(LED, GPIO_DIRECTION_OUT);

	gpio_set_pin_function(LED, GPIO_PIN_FUNCTION_OFF);

	EXTERNAL_IRQ_0_init();
 2e2:	4b04      	ldr	r3, [pc, #16]	; (2f4 <system_init+0x3c>)
 2e4:	4798      	blx	r3

	USART_0_init();
 2e6:	4b04      	ldr	r3, [pc, #16]	; (2f8 <system_init+0x40>)
 2e8:	4798      	blx	r3
}
 2ea:	bd10      	pop	{r4, pc}
 2ec:	000007e5 	.word	0x000007e5
 2f0:	40008000 	.word	0x40008000
 2f4:	000001b5 	.word	0x000001b5
 2f8:	00000281 	.word	0x00000281

000002fc <atomic_enter_critical>:
 */
__STATIC_FORCEINLINE uint32_t __get_PRIMASK(void)
{
  uint32_t result;

  __ASM volatile ("MRS %0, primask" : "=r" (result) :: "memory");
 2fc:	f3ef 8310 	mrs	r3, PRIMASK
/**
 * \brief Disable interrupts, enter critical section
 */
void atomic_enter_critical(hal_atomic_t volatile *atomic)
{
	*atomic = __get_PRIMASK();
 300:	6003      	str	r3, [r0, #0]
  __ASM volatile ("cpsid i" : : : "memory");
 302:	b672      	cpsid	i
  \details Ensures the apparent order of the explicit memory operations before
           and after the instruction, without ensuring their completion.
 */
__STATIC_FORCEINLINE void __DMB(void)
{
  __ASM volatile ("dmb 0xF":::"memory");
 304:	f3bf 8f5f 	dmb	sy
	__disable_irq();
	__DMB();
}
 308:	4770      	bx	lr

0000030a <atomic_leave_critical>:
 30a:	f3bf 8f5f 	dmb	sy
 * \brief Exit atomic section
 */
void atomic_leave_critical(hal_atomic_t volatile *atomic)
{
	__DMB();
	__set_PRIMASK(*atomic);
 30e:	6803      	ldr	r3, [r0, #0]
  __ASM volatile ("MSR primask, %0" : : "r" (priMask) : "memory");
 310:	f383 8810 	msr	PRIMASK, r3
}
 314:	4770      	bx	lr
	...

00000318 <process_ext_irq>:
 * \brief Interrupt processing routine
 *
 * \param[in] pin The pin which triggered the interrupt
 */
static void process_ext_irq(const uint32_t pin)
{
 318:	b570      	push	{r4, r5, r6, lr}
		middle = (upper + lower) >> 1;
		if (middle >= EXT_IRQ_AMOUNT) {
			return;
		}

		if (ext_irqs[middle].pin == pin) {
 31a:	4b0c      	ldr	r3, [pc, #48]	; (34c <process_ext_irq+0x34>)
 31c:	685c      	ldr	r4, [r3, #4]
 31e:	42a0      	cmp	r0, r4
 320:	d00e      	beq.n	340 <process_ext_irq+0x28>
 322:	2201      	movs	r2, #1
 324:	2100      	movs	r1, #0
			}
			return;
		}

		if (ext_irqs[middle].pin < pin) {
			lower = middle + 1;
 326:	2601      	movs	r6, #1
		} else {
			upper = middle - 1;
 328:	25ff      	movs	r5, #255	; 0xff
 32a:	e003      	b.n	334 <process_ext_irq+0x1c>
 32c:	002a      	movs	r2, r5
		middle = (upper + lower) >> 1;
 32e:	1853      	adds	r3, r2, r1
		if (middle >= EXT_IRQ_AMOUNT) {
 330:	085b      	lsrs	r3, r3, #1
 332:	d10a      	bne.n	34a <process_ext_irq+0x32>
		if (ext_irqs[middle].pin < pin) {
 334:	42a0      	cmp	r0, r4
 336:	d9f9      	bls.n	32c <process_ext_irq+0x14>
	while (upper >= lower) {
 338:	2a00      	cmp	r2, #0
 33a:	d006      	beq.n	34a <process_ext_irq+0x32>
			lower = middle + 1;
 33c:	0031      	movs	r1, r6
 33e:	e7f6      	b.n	32e <process_ext_irq+0x16>
			if (ext_irqs[middle].cb) {
 340:	4b02      	ldr	r3, [pc, #8]	; (34c <process_ext_irq+0x34>)
 342:	681b      	ldr	r3, [r3, #0]
 344:	2b00      	cmp	r3, #0
 346:	d000      	beq.n	34a <process_ext_irq+0x32>
				ext_irqs[middle].cb();
 348:	4798      	blx	r3
		}
	}
}
 34a:	bd70      	pop	{r4, r5, r6, pc}
 34c:	20000104 	.word	0x20000104

00000350 <ext_irq_init>:
{
 350:	b510      	push	{r4, lr}
		ext_irqs[i].pin = 0xFFFFFFFF;
 352:	4b05      	ldr	r3, [pc, #20]	; (368 <ext_irq_init+0x18>)
 354:	2201      	movs	r2, #1
 356:	4252      	negs	r2, r2
 358:	605a      	str	r2, [r3, #4]
		ext_irqs[i].cb  = NULL;
 35a:	2200      	movs	r2, #0
 35c:	601a      	str	r2, [r3, #0]
	return _ext_irq_init(process_ext_irq);
 35e:	4803      	ldr	r0, [pc, #12]	; (36c <ext_irq_init+0x1c>)
 360:	4b03      	ldr	r3, [pc, #12]	; (370 <ext_irq_init+0x20>)
 362:	4798      	blx	r3
}
 364:	bd10      	pop	{r4, pc}
 366:	46c0      	nop			; (mov r8, r8)
 368:	20000104 	.word	0x20000104
 36c:	00000319 	.word	0x00000319
 370:	00000835 	.word	0x00000835

00000374 <io_write>:

/**
 * \brief I/O write interface
 */
int32_t io_write(struct io_descriptor *const io_descr, const uint8_t *const buf, const uint16_t length)
{
 374:	b570      	push	{r4, r5, r6, lr}
 376:	0006      	movs	r6, r0
 378:	000c      	movs	r4, r1
 37a:	0015      	movs	r5, r2
	ASSERT(io_descr && buf);
 37c:	2800      	cmp	r0, #0
 37e:	d00d      	beq.n	39c <io_write+0x28>
 380:	0008      	movs	r0, r1
 382:	1e43      	subs	r3, r0, #1
 384:	4198      	sbcs	r0, r3
 386:	b2c0      	uxtb	r0, r0
 388:	2234      	movs	r2, #52	; 0x34
 38a:	4905      	ldr	r1, [pc, #20]	; (3a0 <io_write+0x2c>)
 38c:	4b05      	ldr	r3, [pc, #20]	; (3a4 <io_write+0x30>)
 38e:	4798      	blx	r3
	return io_descr->write(io_descr, buf, length);
 390:	6833      	ldr	r3, [r6, #0]
 392:	002a      	movs	r2, r5
 394:	0021      	movs	r1, r4
 396:	0030      	movs	r0, r6
 398:	4798      	blx	r3
}
 39a:	bd70      	pop	{r4, r5, r6, pc}
 39c:	2000      	movs	r0, #0
 39e:	e7f3      	b.n	388 <io_write+0x14>
 3a0:	00000e78 	.word	0x00000e78
 3a4:	000006dd 	.word	0x000006dd

000003a8 <io_read>:

/**
 * \brief I/O read interface
 */
int32_t io_read(struct io_descriptor *const io_descr, uint8_t *const buf, const uint16_t length)
{
 3a8:	b570      	push	{r4, r5, r6, lr}
 3aa:	0006      	movs	r6, r0
 3ac:	000c      	movs	r4, r1
 3ae:	0015      	movs	r5, r2
	ASSERT(io_descr && buf);
 3b0:	2800      	cmp	r0, #0
 3b2:	d00d      	beq.n	3d0 <io_read+0x28>
 3b4:	0008      	movs	r0, r1
 3b6:	1e43      	subs	r3, r0, #1
 3b8:	4198      	sbcs	r0, r3
 3ba:	b2c0      	uxtb	r0, r0
 3bc:	223d      	movs	r2, #61	; 0x3d
 3be:	4905      	ldr	r1, [pc, #20]	; (3d4 <io_read+0x2c>)
 3c0:	4b05      	ldr	r3, [pc, #20]	; (3d8 <io_read+0x30>)
 3c2:	4798      	blx	r3
	return io_descr->read(io_descr, buf, length);
 3c4:	6873      	ldr	r3, [r6, #4]
 3c6:	002a      	movs	r2, r5
 3c8:	0021      	movs	r1, r4
 3ca:	0030      	movs	r0, r6
 3cc:	4798      	blx	r3
}
 3ce:	bd70      	pop	{r4, r5, r6, pc}
 3d0:	2000      	movs	r0, #0
 3d2:	e7f3      	b.n	3bc <io_read+0x14>
 3d4:	00000e78 	.word	0x00000e78
 3d8:	000006dd 	.word	0x000006dd

000003dc <usart_transmission_complete>:
 * \brief Process completion of data sending
 *
 * \param[in] device The pointer to device structure
 */
static void usart_transmission_complete(struct _usart_async_device *device)
{
 3dc:	b510      	push	{r4, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
 3de:	3808      	subs	r0, #8

	descr->stat = 0;
 3e0:	2300      	movs	r3, #0
 3e2:	6303      	str	r3, [r0, #48]	; 0x30
	if (descr->usart_cb.tx_done) {
 3e4:	6a43      	ldr	r3, [r0, #36]	; 0x24
 3e6:	2b00      	cmp	r3, #0
 3e8:	d000      	beq.n	3ec <usart_transmission_complete+0x10>
		descr->usart_cb.tx_done(descr);
 3ea:	4798      	blx	r3
	}
}
 3ec:	bd10      	pop	{r4, pc}

000003ee <usart_error>:
 * \brief Process error interrupt
 *
 * \param[in] device The pointer to device structure
 */
static void usart_error(struct _usart_async_device *device)
{
 3ee:	b510      	push	{r4, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
 3f0:	3808      	subs	r0, #8

	descr->stat = 0;
 3f2:	2300      	movs	r3, #0
 3f4:	6303      	str	r3, [r0, #48]	; 0x30
	if (descr->usart_cb.error) {
 3f6:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 3f8:	2b00      	cmp	r3, #0
 3fa:	d000      	beq.n	3fe <usart_error+0x10>
		descr->usart_cb.error(descr);
 3fc:	4798      	blx	r3
	}
}
 3fe:	bd10      	pop	{r4, pc}

00000400 <usart_fill_rx_buffer>:
{
 400:	b510      	push	{r4, lr}
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
 402:	0004      	movs	r4, r0
	ringbuffer_put(&descr->rx, data);
 404:	302c      	adds	r0, #44	; 0x2c
 406:	4b04      	ldr	r3, [pc, #16]	; (418 <usart_fill_rx_buffer+0x18>)
 408:	4798      	blx	r3
	if (descr->usart_cb.rx_done) {
 40a:	6a23      	ldr	r3, [r4, #32]
	struct usart_async_descriptor *descr = CONTAINER_OF(device, struct usart_async_descriptor, device);
 40c:	3c08      	subs	r4, #8
	if (descr->usart_cb.rx_done) {
 40e:	2b00      	cmp	r3, #0
 410:	d001      	beq.n	416 <usart_fill_rx_buffer+0x16>
		descr->usart_cb.rx_done(descr);
 412:	0020      	movs	r0, r4
 414:	4798      	blx	r3
}
 416:	bd10      	pop	{r4, pc}
 418:	00000781 	.word	0x00000781

0000041c <usart_async_write>:
{
 41c:	b570      	push	{r4, r5, r6, lr}
 41e:	0004      	movs	r4, r0
 420:	000e      	movs	r6, r1
 422:	0015      	movs	r5, r2
	ASSERT(descr && buf && length);
 424:	2800      	cmp	r0, #0
 426:	d01d      	beq.n	464 <usart_async_write+0x48>
 428:	2900      	cmp	r1, #0
 42a:	d01d      	beq.n	468 <usart_async_write+0x4c>
 42c:	0010      	movs	r0, r2
 42e:	1e43      	subs	r3, r0, #1
 430:	4198      	sbcs	r0, r3
 432:	223c      	movs	r2, #60	; 0x3c
 434:	32ff      	adds	r2, #255	; 0xff
 436:	490f      	ldr	r1, [pc, #60]	; (474 <usart_async_write+0x58>)
 438:	4b0f      	ldr	r3, [pc, #60]	; (478 <usart_async_write+0x5c>)
 43a:	4798      	blx	r3
	if (descr->tx_por != descr->tx_buffer_length) {
 43c:	2344      	movs	r3, #68	; 0x44
 43e:	5ae2      	ldrh	r2, [r4, r3]
 440:	3308      	adds	r3, #8
 442:	5ae3      	ldrh	r3, [r4, r3]
 444:	429a      	cmp	r2, r3
 446:	d111      	bne.n	46c <usart_async_write+0x50>
	descr->tx_buffer        = (uint8_t *)buf;
 448:	64a6      	str	r6, [r4, #72]	; 0x48
	descr->tx_buffer_length = length;
 44a:	234c      	movs	r3, #76	; 0x4c
 44c:	52e5      	strh	r5, [r4, r3]
	descr->tx_por           = 0;
 44e:	2200      	movs	r2, #0
 450:	3b08      	subs	r3, #8
 452:	52e2      	strh	r2, [r4, r3]
	descr->stat             = USART_ASYNC_STATUS_BUSY;
 454:	3b43      	subs	r3, #67	; 0x43
 456:	6323      	str	r3, [r4, #48]	; 0x30
	_usart_async_enable_byte_sent_irq(&descr->device);
 458:	0020      	movs	r0, r4
 45a:	3008      	adds	r0, #8
 45c:	4b07      	ldr	r3, [pc, #28]	; (47c <usart_async_write+0x60>)
 45e:	4798      	blx	r3
	return (int32_t)length;
 460:	0028      	movs	r0, r5
}
 462:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(descr && buf && length);
 464:	2000      	movs	r0, #0
 466:	e7e4      	b.n	432 <usart_async_write+0x16>
 468:	2000      	movs	r0, #0
 46a:	e7e2      	b.n	432 <usart_async_write+0x16>
		return ERR_NO_RESOURCE;
 46c:	201c      	movs	r0, #28
 46e:	4240      	negs	r0, r0
 470:	e7f7      	b.n	462 <usart_async_write+0x46>
 472:	46c0      	nop			; (mov r8, r8)
 474:	00000e8c 	.word	0x00000e8c
 478:	000006dd 	.word	0x000006dd
 47c:	00000b8d 	.word	0x00000b8d

00000480 <usart_process_byte_sent>:
{
 480:	b570      	push	{r4, r5, r6, lr}
 482:	0004      	movs	r4, r0
	if (descr->tx_por != descr->tx_buffer_length) {
 484:	0001      	movs	r1, r0
 486:	3908      	subs	r1, #8
 488:	8f83      	ldrh	r3, [r0, #60]	; 0x3c
 48a:	224c      	movs	r2, #76	; 0x4c
 48c:	5a8a      	ldrh	r2, [r1, r2]
 48e:	429a      	cmp	r2, r3
 490:	d00c      	beq.n	4ac <usart_process_byte_sent+0x2c>
		_usart_async_write_byte(&descr->device, descr->tx_buffer[descr->tx_por++]);
 492:	000a      	movs	r2, r1
 494:	6c89      	ldr	r1, [r1, #72]	; 0x48
 496:	1c5d      	adds	r5, r3, #1
 498:	2044      	movs	r0, #68	; 0x44
 49a:	5215      	strh	r5, [r2, r0]
 49c:	5cc9      	ldrb	r1, [r1, r3]
 49e:	0020      	movs	r0, r4
 4a0:	4b04      	ldr	r3, [pc, #16]	; (4b4 <usart_process_byte_sent+0x34>)
 4a2:	4798      	blx	r3
		_usart_async_enable_byte_sent_irq(&descr->device);
 4a4:	0020      	movs	r0, r4
 4a6:	4b04      	ldr	r3, [pc, #16]	; (4b8 <usart_process_byte_sent+0x38>)
 4a8:	4798      	blx	r3
}
 4aa:	bd70      	pop	{r4, r5, r6, pc}
		_usart_async_enable_tx_done_irq(&descr->device);
 4ac:	4b03      	ldr	r3, [pc, #12]	; (4bc <usart_process_byte_sent+0x3c>)
 4ae:	4798      	blx	r3
}
 4b0:	e7fb      	b.n	4aa <usart_process_byte_sent+0x2a>
 4b2:	46c0      	nop			; (mov r8, r8)
 4b4:	00000b85 	.word	0x00000b85
 4b8:	00000b8d 	.word	0x00000b8d
 4bc:	00000b95 	.word	0x00000b95

000004c0 <usart_async_read>:
{
 4c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 4c2:	46ce      	mov	lr, r9
 4c4:	4647      	mov	r7, r8
 4c6:	b580      	push	{r7, lr}
 4c8:	b085      	sub	sp, #20
 4ca:	0005      	movs	r5, r0
 4cc:	000e      	movs	r6, r1
 4ce:	0017      	movs	r7, r2
	ASSERT(descr && buf && length);
 4d0:	2800      	cmp	r0, #0
 4d2:	d015      	beq.n	500 <usart_async_read+0x40>
 4d4:	2900      	cmp	r1, #0
 4d6:	d013      	beq.n	500 <usart_async_read+0x40>
 4d8:	2a00      	cmp	r2, #0
 4da:	d12a      	bne.n	532 <usart_async_read+0x72>
 4dc:	22ac      	movs	r2, #172	; 0xac
 4de:	0052      	lsls	r2, r2, #1
 4e0:	4929      	ldr	r1, [pc, #164]	; (588 <usart_async_read+0xc8>)
 4e2:	2000      	movs	r0, #0
 4e4:	4b29      	ldr	r3, [pc, #164]	; (58c <usart_async_read+0xcc>)
 4e6:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
 4e8:	a803      	add	r0, sp, #12
 4ea:	4b29      	ldr	r3, [pc, #164]	; (590 <usart_async_read+0xd0>)
 4ec:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
 4ee:	0028      	movs	r0, r5
 4f0:	3034      	adds	r0, #52	; 0x34
 4f2:	4b28      	ldr	r3, [pc, #160]	; (594 <usart_async_read+0xd4>)
 4f4:	4798      	blx	r3
	CRITICAL_SECTION_LEAVE()
 4f6:	a803      	add	r0, sp, #12
 4f8:	4b27      	ldr	r3, [pc, #156]	; (598 <usart_async_read+0xd8>)
 4fa:	4798      	blx	r3
	uint16_t                       was_read = 0;
 4fc:	2500      	movs	r5, #0
	return (int32_t)was_read;
 4fe:	e03c      	b.n	57a <usart_async_read+0xba>
	ASSERT(descr && buf && length);
 500:	22ac      	movs	r2, #172	; 0xac
 502:	0052      	lsls	r2, r2, #1
 504:	4920      	ldr	r1, [pc, #128]	; (588 <usart_async_read+0xc8>)
 506:	2000      	movs	r0, #0
 508:	4b20      	ldr	r3, [pc, #128]	; (58c <usart_async_read+0xcc>)
 50a:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
 50c:	a803      	add	r0, sp, #12
 50e:	4b20      	ldr	r3, [pc, #128]	; (590 <usart_async_read+0xd0>)
 510:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
 512:	3534      	adds	r5, #52	; 0x34
 514:	0028      	movs	r0, r5
 516:	9501      	str	r5, [sp, #4]
 518:	4b1e      	ldr	r3, [pc, #120]	; (594 <usart_async_read+0xd4>)
 51a:	4798      	blx	r3
 51c:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
 51e:	a803      	add	r0, sp, #12
 520:	4b1d      	ldr	r3, [pc, #116]	; (598 <usart_async_read+0xd8>)
 522:	4798      	blx	r3
	uint16_t                       was_read = 0;
 524:	2500      	movs	r5, #0
	while ((was_read < num) && (was_read < length)) {
 526:	4643      	mov	r3, r8
 528:	2b00      	cmp	r3, #0
 52a:	d026      	beq.n	57a <usart_async_read+0xba>
 52c:	2f00      	cmp	r7, #0
 52e:	d116      	bne.n	55e <usart_async_read+0x9e>
 530:	e023      	b.n	57a <usart_async_read+0xba>
	ASSERT(descr && buf && length);
 532:	22ac      	movs	r2, #172	; 0xac
 534:	0052      	lsls	r2, r2, #1
 536:	4914      	ldr	r1, [pc, #80]	; (588 <usart_async_read+0xc8>)
 538:	2001      	movs	r0, #1
 53a:	4b14      	ldr	r3, [pc, #80]	; (58c <usart_async_read+0xcc>)
 53c:	4798      	blx	r3
	CRITICAL_SECTION_ENTER()
 53e:	a803      	add	r0, sp, #12
 540:	4b13      	ldr	r3, [pc, #76]	; (590 <usart_async_read+0xd0>)
 542:	4798      	blx	r3
	num = ringbuffer_num(&descr->rx);
 544:	3534      	adds	r5, #52	; 0x34
 546:	0028      	movs	r0, r5
 548:	9501      	str	r5, [sp, #4]
 54a:	4b12      	ldr	r3, [pc, #72]	; (594 <usart_async_read+0xd4>)
 54c:	4798      	blx	r3
 54e:	4680      	mov	r8, r0
	CRITICAL_SECTION_LEAVE()
 550:	a803      	add	r0, sp, #12
 552:	4b11      	ldr	r3, [pc, #68]	; (598 <usart_async_read+0xd8>)
 554:	4798      	blx	r3
	while ((was_read < num) && (was_read < length)) {
 556:	4643      	mov	r3, r8
	uint16_t                       was_read = 0;
 558:	2500      	movs	r5, #0
	while ((was_read < num) && (was_read < length)) {
 55a:	2b00      	cmp	r3, #0
 55c:	d00d      	beq.n	57a <usart_async_read+0xba>
{
 55e:	2400      	movs	r4, #0
		ringbuffer_get(&descr->rx, &buf[was_read++]);
 560:	4b0e      	ldr	r3, [pc, #56]	; (59c <usart_async_read+0xdc>)
 562:	4699      	mov	r9, r3
 564:	1c65      	adds	r5, r4, #1
 566:	b2ad      	uxth	r5, r5
 568:	1931      	adds	r1, r6, r4
 56a:	9801      	ldr	r0, [sp, #4]
 56c:	47c8      	blx	r9
 56e:	3401      	adds	r4, #1
	while ((was_read < num) && (was_read < length)) {
 570:	4544      	cmp	r4, r8
 572:	d202      	bcs.n	57a <usart_async_read+0xba>
 574:	b2a3      	uxth	r3, r4
 576:	429f      	cmp	r7, r3
 578:	d8f4      	bhi.n	564 <usart_async_read+0xa4>
}
 57a:	0028      	movs	r0, r5
 57c:	b005      	add	sp, #20
 57e:	bc0c      	pop	{r2, r3}
 580:	4690      	mov	r8, r2
 582:	4699      	mov	r9, r3
 584:	bdf0      	pop	{r4, r5, r6, r7, pc}
 586:	46c0      	nop			; (mov r8, r8)
 588:	00000e8c 	.word	0x00000e8c
 58c:	000006dd 	.word	0x000006dd
 590:	000002fd 	.word	0x000002fd
 594:	000007c1 	.word	0x000007c1
 598:	0000030b 	.word	0x0000030b
 59c:	00000739 	.word	0x00000739

000005a0 <usart_async_init>:
{
 5a0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 5a2:	0004      	movs	r4, r0
 5a4:	000d      	movs	r5, r1
 5a6:	0016      	movs	r6, r2
 5a8:	001f      	movs	r7, r3
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
 5aa:	2800      	cmp	r0, #0
 5ac:	d026      	beq.n	5fc <usart_async_init+0x5c>
 5ae:	2900      	cmp	r1, #0
 5b0:	d026      	beq.n	600 <usart_async_init+0x60>
 5b2:	2a00      	cmp	r2, #0
 5b4:	d026      	beq.n	604 <usart_async_init+0x64>
 5b6:	0018      	movs	r0, r3
 5b8:	1e43      	subs	r3, r0, #1
 5ba:	4198      	sbcs	r0, r3
 5bc:	223a      	movs	r2, #58	; 0x3a
 5be:	4914      	ldr	r1, [pc, #80]	; (610 <usart_async_init+0x70>)
 5c0:	4b14      	ldr	r3, [pc, #80]	; (614 <usart_async_init+0x74>)
 5c2:	4798      	blx	r3
	if (ERR_NONE != ringbuffer_init(&descr->rx, rx_buffer, rx_buffer_length)) {
 5c4:	0020      	movs	r0, r4
 5c6:	3034      	adds	r0, #52	; 0x34
 5c8:	003a      	movs	r2, r7
 5ca:	0031      	movs	r1, r6
 5cc:	4b12      	ldr	r3, [pc, #72]	; (618 <usart_async_init+0x78>)
 5ce:	4798      	blx	r3
 5d0:	2800      	cmp	r0, #0
 5d2:	d119      	bne.n	608 <usart_async_init+0x68>
	init_status = _usart_async_init(&descr->device, hw);
 5d4:	0020      	movs	r0, r4
 5d6:	3008      	adds	r0, #8
 5d8:	0029      	movs	r1, r5
 5da:	4b10      	ldr	r3, [pc, #64]	; (61c <usart_async_init+0x7c>)
 5dc:	4798      	blx	r3
	if (init_status) {
 5de:	2800      	cmp	r0, #0
 5e0:	d10b      	bne.n	5fa <usart_async_init+0x5a>
	descr->io.read  = usart_async_read;
 5e2:	4b0f      	ldr	r3, [pc, #60]	; (620 <usart_async_init+0x80>)
 5e4:	6063      	str	r3, [r4, #4]
	descr->io.write = usart_async_write;
 5e6:	4b0f      	ldr	r3, [pc, #60]	; (624 <usart_async_init+0x84>)
 5e8:	6023      	str	r3, [r4, #0]
	descr->device.usart_cb.tx_byte_sent = usart_process_byte_sent;
 5ea:	4b0f      	ldr	r3, [pc, #60]	; (628 <usart_async_init+0x88>)
 5ec:	60a3      	str	r3, [r4, #8]
	descr->device.usart_cb.rx_done_cb   = usart_fill_rx_buffer;
 5ee:	4b0f      	ldr	r3, [pc, #60]	; (62c <usart_async_init+0x8c>)
 5f0:	60e3      	str	r3, [r4, #12]
	descr->device.usart_cb.tx_done_cb   = usart_transmission_complete;
 5f2:	4b0f      	ldr	r3, [pc, #60]	; (630 <usart_async_init+0x90>)
 5f4:	6123      	str	r3, [r4, #16]
	descr->device.usart_cb.error_cb     = usart_error;
 5f6:	4b0f      	ldr	r3, [pc, #60]	; (634 <usart_async_init+0x94>)
 5f8:	6163      	str	r3, [r4, #20]
}
 5fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	ASSERT(descr && hw && rx_buffer && rx_buffer_length);
 5fc:	2000      	movs	r0, #0
 5fe:	e7dd      	b.n	5bc <usart_async_init+0x1c>
 600:	2000      	movs	r0, #0
 602:	e7db      	b.n	5bc <usart_async_init+0x1c>
 604:	2000      	movs	r0, #0
 606:	e7d9      	b.n	5bc <usart_async_init+0x1c>
		return ERR_INVALID_ARG;
 608:	200d      	movs	r0, #13
 60a:	4240      	negs	r0, r0
 60c:	e7f5      	b.n	5fa <usart_async_init+0x5a>
 60e:	46c0      	nop			; (mov r8, r8)
 610:	00000e8c 	.word	0x00000e8c
 614:	000006dd 	.word	0x000006dd
 618:	000006e5 	.word	0x000006e5
 61c:	00000af5 	.word	0x00000af5
 620:	000004c1 	.word	0x000004c1
 624:	0000041d 	.word	0x0000041d
 628:	00000481 	.word	0x00000481
 62c:	00000401 	.word	0x00000401
 630:	000003dd 	.word	0x000003dd
 634:	000003ef 	.word	0x000003ef

00000638 <usart_async_enable>:
{
 638:	b510      	push	{r4, lr}
 63a:	0004      	movs	r4, r0
	ASSERT(descr);
 63c:	1e43      	subs	r3, r0, #1
 63e:	4198      	sbcs	r0, r3
 640:	b2c0      	uxtb	r0, r0
 642:	2261      	movs	r2, #97	; 0x61
 644:	4904      	ldr	r1, [pc, #16]	; (658 <usart_async_enable+0x20>)
 646:	4b05      	ldr	r3, [pc, #20]	; (65c <usart_async_enable+0x24>)
 648:	4798      	blx	r3
	_usart_async_enable(&descr->device);
 64a:	0020      	movs	r0, r4
 64c:	3008      	adds	r0, #8
 64e:	4b04      	ldr	r3, [pc, #16]	; (660 <usart_async_enable+0x28>)
 650:	4798      	blx	r3
}
 652:	2000      	movs	r0, #0
 654:	bd10      	pop	{r4, pc}
 656:	46c0      	nop			; (mov r8, r8)
 658:	00000e8c 	.word	0x00000e8c
 65c:	000006dd 	.word	0x000006dd
 660:	00000b71 	.word	0x00000b71

00000664 <usart_async_register_callback>:
{
 664:	b570      	push	{r4, r5, r6, lr}
 666:	0005      	movs	r5, r0
 668:	000e      	movs	r6, r1
 66a:	0014      	movs	r4, r2
	ASSERT(descr);
 66c:	1e43      	subs	r3, r0, #1
 66e:	4198      	sbcs	r0, r3
 670:	b2c0      	uxtb	r0, r0
 672:	2283      	movs	r2, #131	; 0x83
 674:	4916      	ldr	r1, [pc, #88]	; (6d0 <usart_async_register_callback+0x6c>)
 676:	4b17      	ldr	r3, [pc, #92]	; (6d4 <usart_async_register_callback+0x70>)
 678:	4798      	blx	r3
	switch (type) {
 67a:	2e01      	cmp	r6, #1
 67c:	d011      	beq.n	6a2 <usart_async_register_callback+0x3e>
 67e:	2e00      	cmp	r6, #0
 680:	d004      	beq.n	68c <usart_async_register_callback+0x28>
 682:	2e02      	cmp	r6, #2
 684:	d018      	beq.n	6b8 <usart_async_register_callback+0x54>
		return ERR_INVALID_ARG;
 686:	200d      	movs	r0, #13
 688:	4240      	negs	r0, r0
 68a:	e009      	b.n	6a0 <usart_async_register_callback+0x3c>
		descr->usart_cb.rx_done = cb;
 68c:	62ac      	str	r4, [r5, #40]	; 0x28
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_RX_DONE, NULL != cb);
 68e:	1e62      	subs	r2, r4, #1
 690:	4194      	sbcs	r4, r2
 692:	b2e2      	uxtb	r2, r4
 694:	0028      	movs	r0, r5
 696:	3008      	adds	r0, #8
 698:	2101      	movs	r1, #1
 69a:	4b0f      	ldr	r3, [pc, #60]	; (6d8 <usart_async_register_callback+0x74>)
 69c:	4798      	blx	r3
	return ERR_NONE;
 69e:	2000      	movs	r0, #0
}
 6a0:	bd70      	pop	{r4, r5, r6, pc}
		descr->usart_cb.tx_done = cb;
 6a2:	626c      	str	r4, [r5, #36]	; 0x24
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_TX_DONE, NULL != cb);
 6a4:	1e62      	subs	r2, r4, #1
 6a6:	4194      	sbcs	r4, r2
 6a8:	b2e2      	uxtb	r2, r4
 6aa:	0028      	movs	r0, r5
 6ac:	3008      	adds	r0, #8
 6ae:	2102      	movs	r1, #2
 6b0:	4b09      	ldr	r3, [pc, #36]	; (6d8 <usart_async_register_callback+0x74>)
 6b2:	4798      	blx	r3
	return ERR_NONE;
 6b4:	2000      	movs	r0, #0
		break;
 6b6:	e7f3      	b.n	6a0 <usart_async_register_callback+0x3c>
		descr->usart_cb.error = cb;
 6b8:	62ec      	str	r4, [r5, #44]	; 0x2c
		_usart_async_set_irq_state(&descr->device, USART_ASYNC_ERROR, NULL != cb);
 6ba:	1e62      	subs	r2, r4, #1
 6bc:	4194      	sbcs	r4, r2
 6be:	b2e2      	uxtb	r2, r4
 6c0:	0028      	movs	r0, r5
 6c2:	3008      	adds	r0, #8
 6c4:	2103      	movs	r1, #3
 6c6:	4b04      	ldr	r3, [pc, #16]	; (6d8 <usart_async_register_callback+0x74>)
 6c8:	4798      	blx	r3
	return ERR_NONE;
 6ca:	2000      	movs	r0, #0
		break;
 6cc:	e7e8      	b.n	6a0 <usart_async_register_callback+0x3c>
 6ce:	46c0      	nop			; (mov r8, r8)
 6d0:	00000e8c 	.word	0x00000e8c
 6d4:	000006dd 	.word	0x000006dd
 6d8:	00000b9d 	.word	0x00000b9d

000006dc <assert>:
/**
 * \brief Assert function
 */
void assert(const bool condition, const char *const file, const int line)
{
	if (!(condition)) {
 6dc:	2800      	cmp	r0, #0
 6de:	d100      	bne.n	6e2 <assert+0x6>
		__asm("BKPT #0");
 6e0:	be00      	bkpt	0x0000
	}
	(void)file;
	(void)line;
}
 6e2:	4770      	bx	lr

000006e4 <ringbuffer_init>:

/**
 * \brief Ringbuffer init
 */
int32_t ringbuffer_init(struct ringbuffer *const rb, void *buf, uint32_t size)
{
 6e4:	b570      	push	{r4, r5, r6, lr}
 6e6:	0004      	movs	r4, r0
 6e8:	000e      	movs	r6, r1
 6ea:	0015      	movs	r5, r2
	ASSERT(rb && buf && size);
 6ec:	2800      	cmp	r0, #0
 6ee:	d00b      	beq.n	708 <ringbuffer_init+0x24>
 6f0:	2900      	cmp	r1, #0
 6f2:	d018      	beq.n	726 <ringbuffer_init+0x42>
 6f4:	2001      	movs	r0, #1
 6f6:	2a00      	cmp	r2, #0
 6f8:	d107      	bne.n	70a <ringbuffer_init+0x26>
 6fa:	2228      	movs	r2, #40	; 0x28
 6fc:	490c      	ldr	r1, [pc, #48]	; (730 <ringbuffer_init+0x4c>)
 6fe:	2000      	movs	r0, #0
 700:	4b0c      	ldr	r3, [pc, #48]	; (734 <ringbuffer_init+0x50>)
 702:	4798      	blx	r3

	/*
	 * buf size must be aligned to power of 2
	 */
	if ((size & (size - 1)) != 0) {
 704:	1e6b      	subs	r3, r5, #1
 706:	e007      	b.n	718 <ringbuffer_init+0x34>
	ASSERT(rb && buf && size);
 708:	2000      	movs	r0, #0
 70a:	2228      	movs	r2, #40	; 0x28
 70c:	4908      	ldr	r1, [pc, #32]	; (730 <ringbuffer_init+0x4c>)
 70e:	4b09      	ldr	r3, [pc, #36]	; (734 <ringbuffer_init+0x50>)
 710:	4798      	blx	r3
	if ((size & (size - 1)) != 0) {
 712:	1e6b      	subs	r3, r5, #1
 714:	422b      	tst	r3, r5
 716:	d108      	bne.n	72a <ringbuffer_init+0x46>
		return ERR_INVALID_ARG;
	}

	/* size - 1 is faster in calculation */
	rb->size        = size - 1;
 718:	6063      	str	r3, [r4, #4]
	rb->read_index  = 0;
 71a:	2300      	movs	r3, #0
 71c:	60a3      	str	r3, [r4, #8]
	rb->write_index = rb->read_index;
 71e:	60e3      	str	r3, [r4, #12]
	rb->buf         = (uint8_t *)buf;
 720:	6026      	str	r6, [r4, #0]

	return ERR_NONE;
 722:	2000      	movs	r0, #0
}
 724:	bd70      	pop	{r4, r5, r6, pc}
	ASSERT(rb && buf && size);
 726:	2000      	movs	r0, #0
 728:	e7ef      	b.n	70a <ringbuffer_init+0x26>
		return ERR_INVALID_ARG;
 72a:	200d      	movs	r0, #13
 72c:	4240      	negs	r0, r0
 72e:	e7f9      	b.n	724 <ringbuffer_init+0x40>
 730:	00000eac 	.word	0x00000eac
 734:	000006dd 	.word	0x000006dd

00000738 <ringbuffer_get>:
/**
 * \brief Get one byte from ringbuffer
 *
 */
int32_t ringbuffer_get(struct ringbuffer *const rb, uint8_t *data)
{
 738:	b570      	push	{r4, r5, r6, lr}
 73a:	0004      	movs	r4, r0
 73c:	000d      	movs	r5, r1
	ASSERT(rb && data);
 73e:	2800      	cmp	r0, #0
 740:	d015      	beq.n	76e <ringbuffer_get+0x36>
 742:	0008      	movs	r0, r1
 744:	1e43      	subs	r3, r0, #1
 746:	4198      	sbcs	r0, r3
 748:	b2c0      	uxtb	r0, r0
 74a:	2240      	movs	r2, #64	; 0x40
 74c:	490a      	ldr	r1, [pc, #40]	; (778 <ringbuffer_get+0x40>)
 74e:	4b0b      	ldr	r3, [pc, #44]	; (77c <ringbuffer_get+0x44>)
 750:	4798      	blx	r3

	if (rb->write_index != rb->read_index) {
 752:	68a3      	ldr	r3, [r4, #8]
 754:	68e2      	ldr	r2, [r4, #12]
 756:	429a      	cmp	r2, r3
 758:	d00b      	beq.n	772 <ringbuffer_get+0x3a>
		*data = rb->buf[rb->read_index & rb->size];
 75a:	6862      	ldr	r2, [r4, #4]
 75c:	4013      	ands	r3, r2
 75e:	6822      	ldr	r2, [r4, #0]
 760:	5cd3      	ldrb	r3, [r2, r3]
 762:	702b      	strb	r3, [r5, #0]
		rb->read_index++;
 764:	68a3      	ldr	r3, [r4, #8]
 766:	3301      	adds	r3, #1
 768:	60a3      	str	r3, [r4, #8]
		return ERR_NONE;
 76a:	2000      	movs	r0, #0
	}

	return ERR_NOT_FOUND;
}
 76c:	bd70      	pop	{r4, r5, r6, pc}
 76e:	2000      	movs	r0, #0
 770:	e7eb      	b.n	74a <ringbuffer_get+0x12>
	return ERR_NOT_FOUND;
 772:	200a      	movs	r0, #10
 774:	4240      	negs	r0, r0
 776:	e7f9      	b.n	76c <ringbuffer_get+0x34>
 778:	00000eac 	.word	0x00000eac
 77c:	000006dd 	.word	0x000006dd

00000780 <ringbuffer_put>:
/**
 * \brief Put one byte to ringbuffer
 *
 */
int32_t ringbuffer_put(struct ringbuffer *const rb, uint8_t data)
{
 780:	b570      	push	{r4, r5, r6, lr}
 782:	0004      	movs	r4, r0
 784:	000d      	movs	r5, r1
	ASSERT(rb);
 786:	1e43      	subs	r3, r0, #1
 788:	4198      	sbcs	r0, r3
 78a:	b2c0      	uxtb	r0, r0
 78c:	2251      	movs	r2, #81	; 0x51
 78e:	490a      	ldr	r1, [pc, #40]	; (7b8 <ringbuffer_put+0x38>)
 790:	4b0a      	ldr	r3, [pc, #40]	; (7bc <ringbuffer_put+0x3c>)
 792:	4798      	blx	r3

	rb->buf[rb->write_index & rb->size] = data;
 794:	6863      	ldr	r3, [r4, #4]
 796:	68e2      	ldr	r2, [r4, #12]
 798:	4013      	ands	r3, r2
 79a:	6822      	ldr	r2, [r4, #0]
 79c:	54d5      	strb	r5, [r2, r3]

	/*
	 * buffer full strategy: new data will overwrite the oldest data in
	 * the buffer
	 */
	if ((rb->write_index - rb->read_index) > rb->size) {
 79e:	68e3      	ldr	r3, [r4, #12]
 7a0:	6861      	ldr	r1, [r4, #4]
 7a2:	68a2      	ldr	r2, [r4, #8]
 7a4:	1a9a      	subs	r2, r3, r2
 7a6:	428a      	cmp	r2, r1
 7a8:	d901      	bls.n	7ae <ringbuffer_put+0x2e>
		rb->read_index = rb->write_index - rb->size;
 7aa:	1a59      	subs	r1, r3, r1
 7ac:	60a1      	str	r1, [r4, #8]
	}

	rb->write_index++;
 7ae:	3301      	adds	r3, #1
 7b0:	60e3      	str	r3, [r4, #12]

	return ERR_NONE;
}
 7b2:	2000      	movs	r0, #0
 7b4:	bd70      	pop	{r4, r5, r6, pc}
 7b6:	46c0      	nop			; (mov r8, r8)
 7b8:	00000eac 	.word	0x00000eac
 7bc:	000006dd 	.word	0x000006dd

000007c0 <ringbuffer_num>:

/**
 * \brief Return the element number of ringbuffer
 */
uint32_t ringbuffer_num(const struct ringbuffer *const rb)
{
 7c0:	b510      	push	{r4, lr}
 7c2:	0004      	movs	r4, r0
	ASSERT(rb);
 7c4:	1e43      	subs	r3, r0, #1
 7c6:	4198      	sbcs	r0, r3
 7c8:	b2c0      	uxtb	r0, r0
 7ca:	2267      	movs	r2, #103	; 0x67
 7cc:	4903      	ldr	r1, [pc, #12]	; (7dc <ringbuffer_num+0x1c>)
 7ce:	4b04      	ldr	r3, [pc, #16]	; (7e0 <ringbuffer_num+0x20>)
 7d0:	4798      	blx	r3

	return rb->write_index - rb->read_index;
 7d2:	68e0      	ldr	r0, [r4, #12]
 7d4:	68a3      	ldr	r3, [r4, #8]
 7d6:	1ac0      	subs	r0, r0, r3
}
 7d8:	bd10      	pop	{r4, pc}
 7da:	46c0      	nop			; (mov r8, r8)
 7dc:	00000eac 	.word	0x00000eac
 7e0:	000006dd 	.word	0x000006dd

000007e4 <_init_chip>:

/**
 * \brief Initialize the hardware abstraction layer
 */
void _init_chip(void)
{
 7e4:	b510      	push	{r4, lr}
}

static inline void hri_nvmctrl_set_CTRLB_RWS_bf(const void *const hw, hri_nvmctrl_ctrlb_reg_t mask)
{
	NVMCTRL_CRITICAL_SECTION_ENTER();
	((Nvmctrl *)hw)->CTRLB.reg |= NVMCTRL_CTRLB_RWS(mask);
 7e6:	4b08      	ldr	r3, [pc, #32]	; (808 <_init_chip+0x24>)
 7e8:	685a      	ldr	r2, [r3, #4]
 7ea:	605a      	str	r2, [r3, #4]
	hri_nvmctrl_set_CTRLB_RWS_bf(NVMCTRL, CONF_NVM_WAIT_STATE);

	_osc32kctrl_init_sources();
 7ec:	4b07      	ldr	r3, [pc, #28]	; (80c <_init_chip+0x28>)
 7ee:	4798      	blx	r3
	_oscctrl_init_sources();
 7f0:	4b07      	ldr	r3, [pc, #28]	; (810 <_init_chip+0x2c>)
 7f2:	4798      	blx	r3
	_mclk_init();
 7f4:	4b07      	ldr	r3, [pc, #28]	; (814 <_init_chip+0x30>)
 7f6:	4798      	blx	r3
#if _GCLK_INIT_1ST
	_gclk_init_generators_by_fref(_GCLK_INIT_1ST);
#endif
	_oscctrl_init_referenced_generators();
 7f8:	4b07      	ldr	r3, [pc, #28]	; (818 <_init_chip+0x34>)
 7fa:	4798      	blx	r3
	_gclk_init_generators_by_fref(_GCLK_INIT_LAST);
 7fc:	20ff      	movs	r0, #255	; 0xff
 7fe:	4b07      	ldr	r3, [pc, #28]	; (81c <_init_chip+0x38>)
 800:	4798      	blx	r3

	_div_init();
 802:	4b07      	ldr	r3, [pc, #28]	; (820 <_init_chip+0x3c>)
 804:	4798      	blx	r3
#endif

#if (CONF_PORT_EVCTRL_PORT_0 | CONF_PORT_EVCTRL_PORT_1 | CONF_PORT_EVCTRL_PORT_2 | CONF_PORT_EVCTRL_PORT_3)
	_port_event_init();
#endif
}
 806:	bd10      	pop	{r4, pc}
 808:	41004000 	.word	0x41004000
 80c:	000009fd 	.word	0x000009fd
 810:	00000a15 	.word	0x00000a15
 814:	000009f1 	.word	0x000009f1
 818:	00000a55 	.word	0x00000a55
 81c:	000009cd 	.word	0x000009cd
 820:	00000825 	.word	0x00000825

00000824 <_div_init>:

static inline void hri_divas_write_CTRLA_DLZ_bit(const void *const hw, bool value)
{
	uint8_t tmp;
	DIVAS_CRITICAL_SECTION_ENTER();
	tmp = ((Divas *)hw)->CTRLA.reg;
 824:	2290      	movs	r2, #144	; 0x90
 826:	05d2      	lsls	r2, r2, #23
 828:	7813      	ldrb	r3, [r2, #0]
	tmp &= ~DIVAS_CTRLA_DLZ;
 82a:	2102      	movs	r1, #2
 82c:	438b      	bics	r3, r1
	tmp |= value << DIVAS_CTRLA_DLZ_Pos;
	((Divas *)hw)->CTRLA.reg = tmp;
 82e:	7013      	strb	r3, [r2, #0]
 * \brief Initialize hardware for division operation
 */
void _div_init(void)
{
	hri_divas_write_CTRLA_DLZ_bit(DIVAS, CONF_DIVAS_DLZ);
}
 830:	4770      	bx	lr
	...

00000834 <_ext_irq_init>:
	};
}

static inline bool hri_eic_is_syncing(const void *const hw, hri_eic_syncbusy_reg_t reg)
{
	return ((Eic *)hw)->SYNCBUSY.reg & reg;
 834:	4b2a      	ldr	r3, [pc, #168]	; (8e0 <_ext_irq_init+0xac>)
 836:	685b      	ldr	r3, [r3, #4]
/**
 * \brief Initialize external interrupt module
 */
int32_t _ext_irq_init(void (*cb)(const uint32_t pin))
{
	if (!hri_eic_is_syncing(EIC, EIC_SYNCBUSY_SWRST)) {
 838:	07db      	lsls	r3, r3, #31
 83a:	d41f      	bmi.n	87c <_ext_irq_init+0x48>
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
 83c:	4928      	ldr	r1, [pc, #160]	; (8e0 <_ext_irq_init+0xac>)
 83e:	2203      	movs	r2, #3
 840:	684b      	ldr	r3, [r1, #4]
 842:	421a      	tst	r2, r3
 844:	d1fc      	bne.n	840 <_ext_irq_init+0xc>

static inline hri_eic_ctrla_reg_t hri_eic_get_CTRLA_reg(const void *const hw, hri_eic_ctrla_reg_t mask)
{
	uint8_t tmp;
	hri_eic_wait_for_sync(hw, EIC_SYNCBUSY_MASK);
	tmp = ((Eic *)hw)->CTRLA.reg;
 846:	4b26      	ldr	r3, [pc, #152]	; (8e0 <_ext_irq_init+0xac>)
 848:	781b      	ldrb	r3, [r3, #0]
		if (hri_eic_get_CTRLA_reg(EIC, EIC_CTRLA_ENABLE)) {
 84a:	079b      	lsls	r3, r3, #30
 84c:	d50e      	bpl.n	86c <_ext_irq_init+0x38>
	((Eic *)hw)->CTRLA.reg &= ~EIC_CTRLA_ENABLE;
 84e:	4a24      	ldr	r2, [pc, #144]	; (8e0 <_ext_irq_init+0xac>)
 850:	7813      	ldrb	r3, [r2, #0]
 852:	2102      	movs	r1, #2
 854:	438b      	bics	r3, r1
 856:	7013      	strb	r3, [r2, #0]
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
 858:	0011      	movs	r1, r2
 85a:	2203      	movs	r2, #3
 85c:	684b      	ldr	r3, [r1, #4]
 85e:	421a      	tst	r2, r3
 860:	d1fc      	bne.n	85c <_ext_irq_init+0x28>
 862:	491f      	ldr	r1, [pc, #124]	; (8e0 <_ext_irq_init+0xac>)
 864:	2202      	movs	r2, #2
 866:	684b      	ldr	r3, [r1, #4]
 868:	421a      	tst	r2, r3
 86a:	d1fc      	bne.n	866 <_ext_irq_init+0x32>
}

static inline void hri_eic_write_CTRLA_reg(const void *const hw, hri_eic_ctrla_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CTRLA.reg = data;
 86c:	2201      	movs	r2, #1
 86e:	4b1c      	ldr	r3, [pc, #112]	; (8e0 <_ext_irq_init+0xac>)
 870:	701a      	strb	r2, [r3, #0]
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
 872:	0019      	movs	r1, r3
 874:	3202      	adds	r2, #2
 876:	684b      	ldr	r3, [r1, #4]
 878:	421a      	tst	r2, r3
 87a:	d1fc      	bne.n	876 <_ext_irq_init+0x42>
 87c:	4918      	ldr	r1, [pc, #96]	; (8e0 <_ext_irq_init+0xac>)
 87e:	2201      	movs	r2, #1
 880:	684b      	ldr	r3, [r1, #4]
 882:	421a      	tst	r2, r3
 884:	d1fc      	bne.n	880 <_ext_irq_init+0x4c>
	tmp = ((Eic *)hw)->CTRLA.reg;
 886:	4a16      	ldr	r2, [pc, #88]	; (8e0 <_ext_irq_init+0xac>)
 888:	7813      	ldrb	r3, [r2, #0]
	tmp &= ~EIC_CTRLA_CKSEL;
 88a:	2110      	movs	r1, #16
 88c:	438b      	bics	r3, r1
	((Eic *)hw)->CTRLA.reg = tmp;
 88e:	7013      	strb	r3, [r2, #0]
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
 890:	0011      	movs	r1, r2
 892:	2203      	movs	r2, #3
 894:	684b      	ldr	r3, [r1, #4]
 896:	421a      	tst	r2, r3
 898:	d1fc      	bne.n	894 <_ext_irq_init+0x60>
}

static inline void hri_eic_write_NMICTRL_reg(const void *const hw, hri_eic_nmictrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->NMICTRL.reg = data;
 89a:	4b11      	ldr	r3, [pc, #68]	; (8e0 <_ext_irq_init+0xac>)
 89c:	2200      	movs	r2, #0
 89e:	705a      	strb	r2, [r3, #1]
}

static inline void hri_eic_write_EVCTRL_reg(const void *const hw, hri_eic_evctrl_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->EVCTRL.reg = data;
 8a0:	609a      	str	r2, [r3, #8]
}

static inline void hri_eic_write_ASYNCH_reg(const void *const hw, hri_eic_asynch_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->ASYNCH.reg = data;
 8a2:	2180      	movs	r1, #128	; 0x80
 8a4:	0049      	lsls	r1, r1, #1
 8a6:	6199      	str	r1, [r3, #24]
}

static inline void hri_eic_write_CONFIG_reg(const void *const hw, uint8_t index, hri_eic_config_reg_t data)
{
	EIC_CRITICAL_SECTION_ENTER();
	((Eic *)hw)->CONFIG[index].reg = data;
 8a8:	61da      	str	r2, [r3, #28]
 8aa:	3205      	adds	r2, #5
 8ac:	621a      	str	r2, [r3, #32]
	((Eic *)hw)->CTRLA.reg |= EIC_CTRLA_ENABLE;
 8ae:	781a      	ldrb	r2, [r3, #0]
 8b0:	39fe      	subs	r1, #254	; 0xfe
 8b2:	430a      	orrs	r2, r1
 8b4:	701a      	strb	r2, [r3, #0]
	while (((Eic *)hw)->SYNCBUSY.reg & reg) {
 8b6:	0019      	movs	r1, r3
 8b8:	2203      	movs	r2, #3
 8ba:	684b      	ldr	r3, [r1, #4]
 8bc:	421a      	tst	r2, r3
 8be:	d1fc      	bne.n	8ba <_ext_irq_init+0x86>
 */
__STATIC_INLINE void __NVIC_DisableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8c0:	4b08      	ldr	r3, [pc, #32]	; (8e4 <_ext_irq_init+0xb0>)
 8c2:	2208      	movs	r2, #8
 8c4:	2180      	movs	r1, #128	; 0x80
 8c6:	505a      	str	r2, [r3, r1]
  __ASM volatile ("dsb 0xF":::"memory");
 8c8:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 8cc:	f3bf 8f6f 	isb	sy
 */
__STATIC_INLINE void __NVIC_ClearPendingIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
  {
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8d0:	3101      	adds	r1, #1
 8d2:	31ff      	adds	r1, #255	; 0xff
 8d4:	505a      	str	r2, [r3, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 8d6:	601a      	str	r2, [r3, #0]
	hri_eic_set_CTRLA_ENABLE_bit(EIC);
	NVIC_DisableIRQ(EIC_IRQn);
	NVIC_ClearPendingIRQ(EIC_IRQn);
	NVIC_EnableIRQ(EIC_IRQn);

	callback = cb;
 8d8:	4b03      	ldr	r3, [pc, #12]	; (8e8 <_ext_irq_init+0xb4>)
 8da:	6018      	str	r0, [r3, #0]

	return ERR_NONE;
}
 8dc:	2000      	movs	r0, #0
 8de:	4770      	bx	lr
 8e0:	40002800 	.word	0x40002800
 8e4:	e000e100 	.word	0xe000e100
 8e8:	2000010c 	.word	0x2000010c

000008ec <EIC_Handler>:

/**
 * \brief EIC interrupt handler
 */
void EIC_Handler(void)
{
 8ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 8ee:	46ce      	mov	lr, r9
 8f0:	4647      	mov	r7, r8
 8f2:	b580      	push	{r7, lr}
 8f4:	b083      	sub	sp, #12
	return ((Eic *)hw)->INTFLAG.reg;
 8f6:	4b2f      	ldr	r3, [pc, #188]	; (9b4 <EIC_Handler+0xc8>)
 8f8:	695a      	ldr	r2, [r3, #20]
	volatile uint32_t flags = hri_eic_read_INTFLAG_reg(EIC);
 8fa:	9201      	str	r2, [sp, #4]
	hri_eic_clear_INTFLAG_reg(EIC, flags);
 8fc:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
 8fe:	615a      	str	r2, [r3, #20]
	ASSERT(callback);
 900:	4b2d      	ldr	r3, [pc, #180]	; (9b8 <EIC_Handler+0xcc>)
 902:	6818      	ldr	r0, [r3, #0]
 904:	1e43      	subs	r3, r0, #1
 906:	4198      	sbcs	r0, r3
 908:	b2c0      	uxtb	r0, r0
 90a:	22da      	movs	r2, #218	; 0xda
 90c:	492b      	ldr	r1, [pc, #172]	; (9bc <EIC_Handler+0xd0>)
 90e:	4b2c      	ldr	r3, [pc, #176]	; (9c0 <EIC_Handler+0xd4>)
 910:	4798      	blx	r3
	while (flags) {
 912:	9b01      	ldr	r3, [sp, #4]
 914:	2b00      	cmp	r3, #0
 916:	d047      	beq.n	9a8 <EIC_Handler+0xbc>
 918:	2301      	movs	r3, #1
 91a:	425b      	negs	r3, r3
 91c:	4699      	mov	r9, r3
		pos = ffs(flags) - 1;
 91e:	4b29      	ldr	r3, [pc, #164]	; (9c4 <EIC_Handler+0xd8>)
 920:	4698      	mov	r8, r3
				callback(pin);
 922:	4f25      	ldr	r7, [pc, #148]	; (9b8 <EIC_Handler+0xcc>)
				if (_map[middle].extint == pos) {
 924:	4d28      	ldr	r5, [pc, #160]	; (9c8 <EIC_Handler+0xdc>)
 926:	e038      	b.n	99a <EIC_Handler+0xae>
					upper = middle - 1;
 928:	3a01      	subs	r2, #1
 92a:	b2d6      	uxtb	r6, r2
			while (upper >= lower) {
 92c:	42b1      	cmp	r1, r6
 92e:	d80c      	bhi.n	94a <EIC_Handler+0x5e>
				middle = (upper + lower) >> 1;
 930:	1873      	adds	r3, r6, r1
 932:	105b      	asrs	r3, r3, #1
 934:	b2da      	uxtb	r2, r3
				if (_map[middle].extint == pos) {
 936:	4003      	ands	r3, r0
 938:	00db      	lsls	r3, r3, #3
 93a:	5d5b      	ldrb	r3, [r3, r5]
 93c:	42a3      	cmp	r3, r4
 93e:	d008      	beq.n	952 <EIC_Handler+0x66>
				if (_map[middle].extint < pos) {
 940:	429c      	cmp	r4, r3
 942:	ddf1      	ble.n	928 <EIC_Handler+0x3c>
					lower = middle + 1;
 944:	3201      	adds	r2, #1
 946:	b2d1      	uxtb	r1, r2
 948:	e7f0      	b.n	92c <EIC_Handler+0x40>
			if (INVALID_PIN_NUMBER != pin) {
 94a:	464b      	mov	r3, r9
 94c:	3301      	adds	r3, #1
 94e:	d005      	beq.n	95c <EIC_Handler+0x70>
 950:	e001      	b.n	956 <EIC_Handler+0x6a>
				if (_map[middle].extint == pos) {
 952:	231c      	movs	r3, #28
 954:	4699      	mov	r9, r3
				callback(pin);
 956:	4648      	mov	r0, r9
 958:	683b      	ldr	r3, [r7, #0]
 95a:	4798      	blx	r3
			flags &= ~(1ul << pos);
 95c:	9b01      	ldr	r3, [sp, #4]
 95e:	2201      	movs	r2, #1
 960:	40a2      	lsls	r2, r4
 962:	4393      	bics	r3, r2
 964:	9301      	str	r3, [sp, #4]
			pos = ffs(flags) - 1;
 966:	9801      	ldr	r0, [sp, #4]
 968:	4b16      	ldr	r3, [pc, #88]	; (9c4 <EIC_Handler+0xd8>)
 96a:	4798      	blx	r3
 96c:	3801      	subs	r0, #1
 96e:	b244      	sxtb	r4, r0
		while (-1 != pos) {
 970:	1c63      	adds	r3, r4, #1
 972:	d00a      	beq.n	98a <EIC_Handler+0x9e>
				if (_map[middle].extint == pos) {
 974:	2c08      	cmp	r4, #8
 976:	d005      	beq.n	984 <EIC_Handler+0x98>
 978:	2308      	movs	r3, #8
 97a:	2200      	movs	r2, #0
 97c:	2100      	movs	r1, #0
 97e:	2601      	movs	r6, #1
 980:	20ff      	movs	r0, #255	; 0xff
 982:	e7dd      	b.n	940 <EIC_Handler+0x54>
 984:	231c      	movs	r3, #28
 986:	4699      	mov	r9, r3
 988:	e7e5      	b.n	956 <EIC_Handler+0x6a>
	return ((Eic *)hw)->INTFLAG.reg;
 98a:	4b0a      	ldr	r3, [pc, #40]	; (9b4 <EIC_Handler+0xc8>)
 98c:	695a      	ldr	r2, [r3, #20]
		flags = hri_eic_read_INTFLAG_reg(EIC);
 98e:	9201      	str	r2, [sp, #4]
		hri_eic_clear_INTFLAG_reg(EIC, flags);
 990:	9a01      	ldr	r2, [sp, #4]
	((Eic *)hw)->INTFLAG.reg = mask;
 992:	615a      	str	r2, [r3, #20]
	while (flags) {
 994:	9b01      	ldr	r3, [sp, #4]
 996:	2b00      	cmp	r3, #0
 998:	d006      	beq.n	9a8 <EIC_Handler+0xbc>
		pos = ffs(flags) - 1;
 99a:	9801      	ldr	r0, [sp, #4]
 99c:	47c0      	blx	r8
 99e:	3801      	subs	r0, #1
 9a0:	b244      	sxtb	r4, r0
		while (-1 != pos) {
 9a2:	1c63      	adds	r3, r4, #1
 9a4:	d1e6      	bne.n	974 <EIC_Handler+0x88>
 9a6:	e7f0      	b.n	98a <EIC_Handler+0x9e>
	_ext_irq_handler();
}
 9a8:	b003      	add	sp, #12
 9aa:	bc0c      	pop	{r2, r3}
 9ac:	4690      	mov	r8, r2
 9ae:	4699      	mov	r9, r3
 9b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
 9b2:	46c0      	nop			; (mov r8, r8)
 9b4:	40002800 	.word	0x40002800
 9b8:	2000010c 	.word	0x2000010c
 9bc:	00000ed8 	.word	0x00000ed8
 9c0:	000006dd 	.word	0x000006dd
 9c4:	00000db9 	.word	0x00000db9
 9c8:	00000ed0 	.word	0x00000ed0

000009cc <_gclk_init_generators_by_fref>:

void _gclk_init_generators_by_fref(uint32_t bm)
{

#if CONF_GCLK_GENERATOR_0_CONFIG == 1
	if (bm & (1ul << 0)) {
 9cc:	07c3      	lsls	r3, r0, #31
 9ce:	d507      	bpl.n	9e0 <_gclk_init_generators_by_fref+0x14>
	((Gclk *)hw)->GENCTRL[index].reg = data;
 9d0:	4a04      	ldr	r2, [pc, #16]	; (9e4 <_gclk_init_generators_by_fref+0x18>)
 9d2:	4b05      	ldr	r3, [pc, #20]	; (9e8 <_gclk_init_generators_by_fref+0x1c>)
 9d4:	621a      	str	r2, [r3, #32]
	while (((Gclk *)hw)->SYNCBUSY.reg & reg) {
 9d6:	0019      	movs	r1, r3
 9d8:	4a04      	ldr	r2, [pc, #16]	; (9ec <_gclk_init_generators_by_fref+0x20>)
 9da:	684b      	ldr	r3, [r1, #4]
 9dc:	4213      	tst	r3, r2
 9de:	d1fc      	bne.n	9da <_gclk_init_generators_by_fref+0xe>
		        | (CONF_GCLK_GEN_8_DIVSEL << GCLK_GENCTRL_DIVSEL_Pos) | (CONF_GCLK_GEN_8_OE << GCLK_GENCTRL_OE_Pos)
		        | (CONF_GCLK_GEN_8_OOV << GCLK_GENCTRL_OOV_Pos) | (CONF_GCLK_GEN_8_IDC << GCLK_GENCTRL_IDC_Pos)
		        | (CONF_GCLK_GENERATOR_8_CONFIG << GCLK_GENCTRL_GENEN_Pos) | CONF_GCLK_GEN_8_SOURCE);
	}
#endif
}
 9e0:	4770      	bx	lr
 9e2:	46c0      	nop			; (mov r8, r8)
 9e4:	00010106 	.word	0x00010106
 9e8:	40001c00 	.word	0x40001c00
 9ec:	000007fd 	.word	0x000007fd

000009f0 <_mclk_init>:
	((Mclk *)hw)->CPUDIV.reg = data;
 9f0:	2201      	movs	r2, #1
 9f2:	4b01      	ldr	r3, [pc, #4]	; (9f8 <_mclk_init+0x8>)
 9f4:	711a      	strb	r2, [r3, #4]
 */
void _mclk_init(void)
{
	void *hw = (void *)MCLK;
	hri_mclk_write_CPUDIV_reg(hw, MCLK_CPUDIV_CPUDIV(CONF_MCLK_CPUDIV));
}
 9f6:	4770      	bx	lr
 9f8:	40000800 	.word	0x40000800

000009fc <_osc32kctrl_init_sources>:
}

static inline hri_osc32kctrl_osculp32k_reg_t hri_osc32kctrl_read_OSCULP32K_CALIB_bf(const void *const hw)
{
	uint32_t tmp;
	tmp = ((Osc32kctrl *)hw)->OSCULP32K.reg;
 9fc:	4b04      	ldr	r3, [pc, #16]	; (a10 <_osc32kctrl_init_sources+0x14>)
 9fe:	69da      	ldr	r2, [r3, #28]
	calib = hri_osc32kctrl_read_OSCULP32K_CALIB_bf(hw);
	hri_osc32kctrl_write_OSCULP32K_reg(hw,
#if CONF_OSC32K_CALIB_ENABLE == 1
	                                   OSC32KCTRL_OSCULP32K_CALIB(CONF_OSC32K_CALIB)
#else
	                                   OSC32KCTRL_OSCULP32K_CALIB(calib)
 a00:	21f8      	movs	r1, #248	; 0xf8
 a02:	0149      	lsls	r1, r1, #5
 a04:	400a      	ands	r2, r1
}

static inline void hri_osc32kctrl_write_OSCULP32K_reg(const void *const hw, hri_osc32kctrl_osculp32k_reg_t data)
{
	OSC32KCTRL_CRITICAL_SECTION_ENTER();
	((Osc32kctrl *)hw)->OSCULP32K.reg = data;
 a06:	61da      	str	r2, [r3, #28]
	((Osc32kctrl *)hw)->RTCCTRL.reg = data;
 a08:	2201      	movs	r2, #1
 a0a:	611a      	str	r2, [r3, #16]
		;
#endif
#endif
	hri_osc32kctrl_write_RTCCTRL_reg(hw, OSC32KCTRL_RTCCTRL_RTCSEL(CONF_RTCCTRL));
	(void)calib;
}
 a0c:	4770      	bx	lr
 a0e:	46c0      	nop			; (mov r8, r8)
 a10:	40001400 	.word	0x40001400

00000a14 <_oscctrl_init_sources>:
}

static inline void hri_oscctrl_write_OSC48MCTRL_reg(const void *const hw, hri_oscctrl_osc48mctrl_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MCTRL.reg = data;
 a14:	4b0e      	ldr	r3, [pc, #56]	; (a50 <_oscctrl_init_sources+0x3c>)
 a16:	2202      	movs	r2, #2
 a18:	751a      	strb	r2, [r3, #20]
}

static inline void hri_oscctrl_write_OSC48MDIV_reg(const void *const hw, hri_oscctrl_osc48mdiv_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MDIV.reg = data;
 a1a:	3209      	adds	r2, #9
 a1c:	755a      	strb	r2, [r3, #21]
	while (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & reg) {
 a1e:	0019      	movs	r1, r3
 a20:	3a07      	subs	r2, #7
 a22:	698b      	ldr	r3, [r1, #24]
 a24:	421a      	tst	r2, r3
 a26:	d1fc      	bne.n	a22 <_oscctrl_init_sources+0xe>
	return (((Oscctrl *)hw)->OSC48MSYNCBUSY.reg & OSCCTRL_OSC48MSYNCBUSY_OSC48MDIV)
 a28:	4909      	ldr	r1, [pc, #36]	; (a50 <_oscctrl_init_sources+0x3c>)
#if CONF_OSC48M_CONFIG == 1
	hri_oscctrl_write_OSC48MCTRL_reg(hw,
	                                 (CONF_OSC48M_RUNSTDBY << OSCCTRL_OSC48MCTRL_RUNSTDBY_Pos)
	                                     | (CONF_OSC48M_ENABLE << OSCCTRL_OSC48MCTRL_ENABLE_Pos));
	hri_oscctrl_write_OSC48MDIV_reg(hw, OSCCTRL_OSC48MDIV_DIV(CONF_OSC48M_DIV));
	while (hri_oscctrl_get_OSC48MSYNCBUSY_OSC48MDIV_bit(hw))
 a2a:	2204      	movs	r2, #4
 a2c:	698b      	ldr	r3, [r1, #24]
 a2e:	421a      	tst	r2, r3
 a30:	d1fc      	bne.n	a2c <_oscctrl_init_sources+0x18>
}

static inline void hri_oscctrl_write_OSC48MSTUP_reg(const void *const hw, hri_oscctrl_osc48mstup_reg_t data)
{
	OSCCTRL_CRITICAL_SECTION_ENTER();
	((Oscctrl *)hw)->OSC48MSTUP.reg = data;
 a32:	2207      	movs	r2, #7
 a34:	4b06      	ldr	r3, [pc, #24]	; (a50 <_oscctrl_init_sources+0x3c>)
 a36:	759a      	strb	r2, [r3, #22]
	return (((Oscctrl *)hw)->STATUS.reg & OSCCTRL_STATUS_OSC48MRDY) >> OSCCTRL_STATUS_OSC48MRDY_Pos;
 a38:	0019      	movs	r1, r3
#endif
#endif

#if CONF_OSC48M_CONFIG == 1
#if CONF_OSC48M_ENABLE == 1
	while (!hri_oscctrl_get_STATUS_OSC48MRDY_bit(hw))
 a3a:	3209      	adds	r2, #9
 a3c:	68cb      	ldr	r3, [r1, #12]
 a3e:	421a      	tst	r2, r3
 a40:	d0fc      	beq.n	a3c <_oscctrl_init_sources+0x28>
	((Oscctrl *)hw)->OSC48MCTRL.reg |= OSCCTRL_OSC48MCTRL_ONDEMAND;
 a42:	4a03      	ldr	r2, [pc, #12]	; (a50 <_oscctrl_init_sources+0x3c>)
 a44:	7d13      	ldrb	r3, [r2, #20]
 a46:	2180      	movs	r1, #128	; 0x80
 a48:	430b      	orrs	r3, r1
 a4a:	7513      	strb	r3, [r2, #20]
#if CONF_OSC48M_ONDEMAND == 1
	hri_oscctrl_set_OSC48MCTRL_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
 a4c:	4770      	bx	lr
 a4e:	46c0      	nop			; (mov r8, r8)
 a50:	40001000 	.word	0x40001000

00000a54 <_oscctrl_init_referenced_generators>:
#if CONF_DPLL_ONDEMAND == 1
	hri_oscctrl_set_DPLLCTRLA_ONDEMAND_bit(hw);
#endif
#endif
	(void)hw;
}
 a54:	4770      	bx	lr
	...

00000a58 <_usart_init>:
 * \param[in] hw The pointer to hardware instance
 *
 * \return The status of initialization
 */
static int32_t _usart_init(void *const hw)
{
 a58:	b510      	push	{r4, lr}
 a5a:	0004      	movs	r4, r0
	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
 a5c:	4b1f      	ldr	r3, [pc, #124]	; (adc <_usart_init+0x84>)
 a5e:	18c3      	adds	r3, r0, r3
 a60:	0a9b      	lsrs	r3, r3, #10
		if (_usarts[i].number == sercom_offset) {
 a62:	b2db      	uxtb	r3, r3
 a64:	2b00      	cmp	r3, #0
 a66:	d004      	beq.n	a72 <_usart_init+0x1a>
	ASSERT(false);
 a68:	4a1d      	ldr	r2, [pc, #116]	; (ae0 <_usart_init+0x88>)
 a6a:	491e      	ldr	r1, [pc, #120]	; (ae4 <_usart_init+0x8c>)
 a6c:	2000      	movs	r0, #0
 a6e:	4b1e      	ldr	r3, [pc, #120]	; (ae8 <_usart_init+0x90>)
 a70:	4798      	blx	r3
	};
}

static inline bool hri_sercomusart_is_syncing(const void *const hw, hri_sercomusart_syncbusy_reg_t reg)
{
	return ((Sercom *)hw)->USART.SYNCBUSY.reg & reg;
 a72:	69e3      	ldr	r3, [r4, #28]
	uint8_t i = _get_sercom_index(hw);

	if (!hri_sercomusart_is_syncing(hw, SERCOM_USART_SYNCBUSY_SWRST)) {
 a74:	07db      	lsls	r3, r3, #31
 a76:	d418      	bmi.n	aaa <_usart_init+0x52>
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
 a78:	2203      	movs	r2, #3
 a7a:	69e3      	ldr	r3, [r4, #28]
 a7c:	421a      	tst	r2, r3
 a7e:	d1fc      	bne.n	a7a <_usart_init+0x22>
static inline hri_sercomusart_ctrla_reg_t hri_sercomusart_get_CTRLA_reg(const void *const           hw,
                                                                        hri_sercomusart_ctrla_reg_t mask)
{
	uint32_t tmp;
	hri_sercomusart_wait_for_sync(hw, SERCOM_USART_SYNCBUSY_SWRST | SERCOM_USART_SYNCBUSY_ENABLE);
	tmp = ((Sercom *)hw)->USART.CTRLA.reg;
 a80:	6823      	ldr	r3, [r4, #0]
		uint32_t mode = _usarts[i].ctrl_a & SERCOM_USART_CTRLA_MODE_Msk;
		if (hri_sercomusart_get_CTRLA_reg(hw, SERCOM_USART_CTRLA_ENABLE)) {
 a82:	079b      	lsls	r3, r3, #30
 a84:	d50b      	bpl.n	a9e <_usart_init+0x46>
	((Sercom *)hw)->USART.CTRLA.reg &= ~SERCOM_USART_CTRLA_ENABLE;
 a86:	6823      	ldr	r3, [r4, #0]
 a88:	2202      	movs	r2, #2
 a8a:	4393      	bics	r3, r2
 a8c:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
 a8e:	3201      	adds	r2, #1
 a90:	69e3      	ldr	r3, [r4, #28]
 a92:	421a      	tst	r2, r3
 a94:	d1fc      	bne.n	a90 <_usart_init+0x38>
 a96:	2202      	movs	r2, #2
 a98:	69e3      	ldr	r3, [r4, #28]
 a9a:	421a      	tst	r2, r3
 a9c:	d1fc      	bne.n	a98 <_usart_init+0x40>
}

static inline void hri_sercomusart_write_CTRLA_reg(const void *const hw, hri_sercomusart_ctrla_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLA.reg = data;
 a9e:	2305      	movs	r3, #5
 aa0:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
 aa2:	2203      	movs	r2, #3
 aa4:	69e3      	ldr	r3, [r4, #28]
 aa6:	421a      	tst	r2, r3
 aa8:	d1fc      	bne.n	aa4 <_usart_init+0x4c>
 aaa:	2201      	movs	r2, #1
 aac:	69e3      	ldr	r3, [r4, #28]
 aae:	421a      	tst	r2, r3
 ab0:	d1fc      	bne.n	aac <_usart_init+0x54>
	((Sercom *)hw)->USART.CTRLA.reg = data;
 ab2:	4b0e      	ldr	r3, [pc, #56]	; (aec <_usart_init+0x94>)
 ab4:	6023      	str	r3, [r4, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
 ab6:	2203      	movs	r2, #3
 ab8:	69e3      	ldr	r3, [r4, #28]
 aba:	421a      	tst	r2, r3
 abc:	d1fc      	bne.n	ab8 <_usart_init+0x60>
}

static inline void hri_sercomusart_write_CTRLB_reg(const void *const hw, hri_sercomusart_ctrlb_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.CTRLB.reg = data;
 abe:	23c0      	movs	r3, #192	; 0xc0
 ac0:	029b      	lsls	r3, r3, #10
 ac2:	6063      	str	r3, [r4, #4]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
 ac4:	2207      	movs	r2, #7
 ac6:	69e3      	ldr	r3, [r4, #28]
 ac8:	421a      	tst	r2, r3
 aca:	d1fc      	bne.n	ac6 <_usart_init+0x6e>
}

static inline void hri_sercomusart_write_BAUD_reg(const void *const hw, hri_sercomusart_baud_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.BAUD.reg = data;
 acc:	4b08      	ldr	r3, [pc, #32]	; (af0 <_usart_init+0x98>)
 ace:	81a3      	strh	r3, [r4, #12]
}

static inline void hri_sercomusart_write_RXPL_reg(const void *const hw, hri_sercomusart_rxpl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.RXPL.reg = data;
 ad0:	2300      	movs	r3, #0
 ad2:	73a3      	strb	r3, [r4, #14]
}

static inline void hri_sercomusart_write_DBGCTRL_reg(const void *const hw, hri_sercomusart_dbgctrl_reg_t data)
{
	SERCOM_CRITICAL_SECTION_ENTER();
	((Sercom *)hw)->USART.DBGCTRL.reg = data;
 ad4:	2230      	movs	r2, #48	; 0x30
 ad6:	54a3      	strb	r3, [r4, r2]

	hri_sercomusart_write_RXPL_reg(hw, _usarts[i].rxpl);
	hri_sercomusart_write_DBGCTRL_reg(hw, _usarts[i].debug_ctrl);

	return ERR_NONE;
}
 ad8:	2000      	movs	r0, #0
 ada:	bd10      	pop	{r4, pc}
 adc:	bdfffc00 	.word	0xbdfffc00
 ae0:	0000025e 	.word	0x0000025e
 ae4:	00000ef0 	.word	0x00000ef0
 ae8:	000006dd 	.word	0x000006dd
 aec:	40100004 	.word	0x40100004
 af0:	fffff62b 	.word	0xfffff62b

00000af4 <_usart_async_init>:
{
 af4:	b570      	push	{r4, r5, r6, lr}
 af6:	0005      	movs	r5, r0
 af8:	000c      	movs	r4, r1
	ASSERT(device);
 afa:	1e43      	subs	r3, r0, #1
 afc:	4198      	sbcs	r0, r3
 afe:	b2c0      	uxtb	r0, r0
 b00:	22c4      	movs	r2, #196	; 0xc4
 b02:	4914      	ldr	r1, [pc, #80]	; (b54 <_usart_async_init+0x60>)
 b04:	4b14      	ldr	r3, [pc, #80]	; (b58 <_usart_async_init+0x64>)
 b06:	4798      	blx	r3
	init_status = _usart_init(hw);
 b08:	0020      	movs	r0, r4
 b0a:	4b14      	ldr	r3, [pc, #80]	; (b5c <_usart_async_init+0x68>)
 b0c:	4798      	blx	r3
	if (init_status) {
 b0e:	2800      	cmp	r0, #0
 b10:	d000      	beq.n	b14 <_usart_async_init+0x20>
}
 b12:	bd70      	pop	{r4, r5, r6, pc}
	device->hw = hw;
 b14:	61ac      	str	r4, [r5, #24]
	if (hw == SERCOM0) {
 b16:	4b12      	ldr	r3, [pc, #72]	; (b60 <_usart_async_init+0x6c>)
 b18:	429c      	cmp	r4, r3
 b1a:	d017      	beq.n	b4c <_usart_async_init+0x58>
	return ((uint32_t)hw - (uint32_t)SERCOM0) >> 10;
 b1c:	4b11      	ldr	r3, [pc, #68]	; (b64 <_usart_async_init+0x70>)
 b1e:	469c      	mov	ip, r3
 b20:	4464      	add	r4, ip
 b22:	0aa4      	lsrs	r4, r4, #10
/**
 * \brief Retrieve IRQ number for the given hardware instance
 */
static uint8_t _sercom_get_irq_num(const void *const hw)
{
	return SERCOM0_IRQn + _sercom_get_hardware_index(hw);
 b24:	3409      	adds	r4, #9
  if ((int32_t)(IRQn) >= 0)
 b26:	b2e3      	uxtb	r3, r4
 b28:	0622      	lsls	r2, r4, #24
 b2a:	d4f2      	bmi.n	b12 <_usart_async_init+0x1e>
    NVIC->ICER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 b2c:	221f      	movs	r2, #31
 b2e:	401a      	ands	r2, r3
 b30:	2301      	movs	r3, #1
 b32:	4093      	lsls	r3, r2
 b34:	4a0c      	ldr	r2, [pc, #48]	; (b68 <_usart_async_init+0x74>)
 b36:	2180      	movs	r1, #128	; 0x80
 b38:	5053      	str	r3, [r2, r1]
  __ASM volatile ("dsb 0xF":::"memory");
 b3a:	f3bf 8f4f 	dsb	sy
  __ASM volatile ("isb 0xF":::"memory");
 b3e:	f3bf 8f6f 	isb	sy
    NVIC->ICPR[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 b42:	3101      	adds	r1, #1
 b44:	31ff      	adds	r1, #255	; 0xff
 b46:	5053      	str	r3, [r2, r1]
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
 b48:	6013      	str	r3, [r2, #0]
 b4a:	e7e2      	b.n	b12 <_usart_async_init+0x1e>
		_sercom0_dev = (struct _usart_async_device *)dev;
 b4c:	4b07      	ldr	r3, [pc, #28]	; (b6c <_usart_async_init+0x78>)
 b4e:	601d      	str	r5, [r3, #0]
	return SERCOM0_IRQn + _sercom_get_hardware_index(hw);
 b50:	2309      	movs	r3, #9
 b52:	e7eb      	b.n	b2c <_usart_async_init+0x38>
 b54:	00000ef0 	.word	0x00000ef0
 b58:	000006dd 	.word	0x000006dd
 b5c:	00000a59 	.word	0x00000a59
 b60:	42000400 	.word	0x42000400
 b64:	bdfffc00 	.word	0xbdfffc00
 b68:	e000e100 	.word	0xe000e100
 b6c:	20000110 	.word	0x20000110

00000b70 <_usart_async_enable>:
	hri_sercomusart_set_CTRLA_ENABLE_bit(device->hw);
 b70:	6982      	ldr	r2, [r0, #24]
	((Sercom *)hw)->USART.CTRLA.reg |= SERCOM_USART_CTRLA_ENABLE;
 b72:	6813      	ldr	r3, [r2, #0]
 b74:	2102      	movs	r1, #2
 b76:	430b      	orrs	r3, r1
 b78:	6013      	str	r3, [r2, #0]
	while (((Sercom *)hw)->USART.SYNCBUSY.reg & reg) {
 b7a:	3101      	adds	r1, #1
 b7c:	69d3      	ldr	r3, [r2, #28]
 b7e:	4219      	tst	r1, r3
 b80:	d1fc      	bne.n	b7c <_usart_async_enable+0xc>
}
 b82:	4770      	bx	lr

00000b84 <_usart_async_write_byte>:
	hri_sercomusart_write_DATA_reg(device->hw, data);
 b84:	6983      	ldr	r3, [r0, #24]
 b86:	b289      	uxth	r1, r1
	((Sercom *)hw)->USART.DATA.reg = data;
 b88:	8519      	strh	r1, [r3, #40]	; 0x28
}
 b8a:	4770      	bx	lr

00000b8c <_usart_async_enable_byte_sent_irq>:
	hri_sercomusart_set_INTEN_DRE_bit(device->hw);
 b8c:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
 b8e:	2201      	movs	r2, #1
 b90:	759a      	strb	r2, [r3, #22]
}
 b92:	4770      	bx	lr

00000b94 <_usart_async_enable_tx_done_irq>:
	hri_sercomusart_set_INTEN_TXC_bit(device->hw);
 b94:	6983      	ldr	r3, [r0, #24]
	((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
 b96:	2202      	movs	r2, #2
 b98:	759a      	strb	r2, [r3, #22]
}
 b9a:	4770      	bx	lr

00000b9c <_usart_async_set_irq_state>:
{
 b9c:	b570      	push	{r4, r5, r6, lr}
 b9e:	0004      	movs	r4, r0
 ba0:	000d      	movs	r5, r1
 ba2:	0016      	movs	r6, r2
	ASSERT(device);
 ba4:	1e43      	subs	r3, r0, #1
 ba6:	4198      	sbcs	r0, r3
 ba8:	b2c0      	uxtb	r0, r0
 baa:	4a16      	ldr	r2, [pc, #88]	; (c04 <_usart_async_set_irq_state+0x68>)
 bac:	4916      	ldr	r1, [pc, #88]	; (c08 <_usart_async_set_irq_state+0x6c>)
 bae:	4b17      	ldr	r3, [pc, #92]	; (c0c <_usart_async_set_irq_state+0x70>)
 bb0:	4798      	blx	r3
	if (USART_ASYNC_BYTE_SENT == type || USART_ASYNC_TX_DONE == type) {
 bb2:	2302      	movs	r3, #2
 bb4:	002a      	movs	r2, r5
 bb6:	439a      	bics	r2, r3
 bb8:	d10e      	bne.n	bd8 <_usart_async_set_irq_state+0x3c>
		hri_sercomusart_write_INTEN_DRE_bit(device->hw, state);
 bba:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
 bbc:	2e00      	cmp	r6, #0
 bbe:	d105      	bne.n	bcc <_usart_async_set_irq_state+0x30>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
 bc0:	2201      	movs	r2, #1
 bc2:	751a      	strb	r2, [r3, #20]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
 bc4:	69a3      	ldr	r3, [r4, #24]
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
 bc6:	3201      	adds	r2, #1
 bc8:	751a      	strb	r2, [r3, #20]
}
 bca:	bd70      	pop	{r4, r5, r6, pc}
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_DRE;
 bcc:	2201      	movs	r2, #1
 bce:	759a      	strb	r2, [r3, #22]
		hri_sercomusart_write_INTEN_TXC_bit(device->hw, state);
 bd0:	69a3      	ldr	r3, [r4, #24]
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_TXC;
 bd2:	3201      	adds	r2, #1
 bd4:	759a      	strb	r2, [r3, #22]
 bd6:	e7f8      	b.n	bca <_usart_async_set_irq_state+0x2e>
	} else if (USART_ASYNC_RX_DONE == type) {
 bd8:	2d01      	cmp	r5, #1
 bda:	d007      	beq.n	bec <_usart_async_set_irq_state+0x50>
	} else if (USART_ASYNC_ERROR == type) {
 bdc:	2d03      	cmp	r5, #3
 bde:	d1f4      	bne.n	bca <_usart_async_set_irq_state+0x2e>
		hri_sercomusart_write_INTEN_ERROR_bit(device->hw, state);
 be0:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
 be2:	2e00      	cmp	r6, #0
 be4:	d00b      	beq.n	bfe <_usart_async_set_irq_state+0x62>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_ERROR;
 be6:	2280      	movs	r2, #128	; 0x80
 be8:	759a      	strb	r2, [r3, #22]
}
 bea:	e7ee      	b.n	bca <_usart_async_set_irq_state+0x2e>
		hri_sercomusart_write_INTEN_RXC_bit(device->hw, state);
 bec:	69a3      	ldr	r3, [r4, #24]
	if (value == 0x0) {
 bee:	2e00      	cmp	r6, #0
 bf0:	d102      	bne.n	bf8 <_usart_async_set_irq_state+0x5c>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_RXC;
 bf2:	2204      	movs	r2, #4
 bf4:	751a      	strb	r2, [r3, #20]
 bf6:	e7e8      	b.n	bca <_usart_async_set_irq_state+0x2e>
		((Sercom *)hw)->USART.INTENSET.reg = SERCOM_USART_INTENSET_RXC;
 bf8:	2204      	movs	r2, #4
 bfa:	759a      	strb	r2, [r3, #22]
 bfc:	e7e5      	b.n	bca <_usart_async_set_irq_state+0x2e>
		((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_ERROR;
 bfe:	2280      	movs	r2, #128	; 0x80
 c00:	751a      	strb	r2, [r3, #20]
 c02:	e7e2      	b.n	bca <_usart_async_set_irq_state+0x2e>
 c04:	0000021e 	.word	0x0000021e
 c08:	00000ef0 	.word	0x00000ef0
 c0c:	000006dd 	.word	0x000006dd

00000c10 <SERCOM0_Handler>:

	return NULL;
}

void SERCOM0_Handler(void)
{
 c10:	b510      	push	{r4, lr}
	_sercom_usart_interrupt_handler(_sercom0_dev);
 c12:	4b19      	ldr	r3, [pc, #100]	; (c78 <SERCOM0_Handler+0x68>)
 c14:	6818      	ldr	r0, [r3, #0]
	void *hw = device->hw;
 c16:	6984      	ldr	r4, [r0, #24]
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_DRE) >> SERCOM_USART_INTFLAG_DRE_Pos;
 c18:	7e23      	ldrb	r3, [r4, #24]
	if (hri_sercomusart_get_interrupt_DRE_bit(hw) && hri_sercomusart_get_INTEN_DRE_bit(hw)) {
 c1a:	07db      	lsls	r3, r3, #31
 c1c:	d502      	bpl.n	c24 <SERCOM0_Handler+0x14>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_DRE) >> SERCOM_USART_INTENSET_DRE_Pos;
 c1e:	7da3      	ldrb	r3, [r4, #22]
 c20:	07db      	lsls	r3, r3, #31
 c22:	d40f      	bmi.n	c44 <SERCOM0_Handler+0x34>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_TXC) >> SERCOM_USART_INTFLAG_TXC_Pos;
 c24:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_TXC_bit(hw) && hri_sercomusart_get_INTEN_TXC_bit(hw)) {
 c26:	079b      	lsls	r3, r3, #30
 c28:	d502      	bpl.n	c30 <SERCOM0_Handler+0x20>
	return (((Sercom *)hw)->USART.INTENSET.reg & SERCOM_USART_INTENSET_TXC) >> SERCOM_USART_INTENSET_TXC_Pos;
 c2a:	7da3      	ldrb	r3, [r4, #22]
 c2c:	079b      	lsls	r3, r3, #30
 c2e:	d40e      	bmi.n	c4e <SERCOM0_Handler+0x3e>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_RXC) >> SERCOM_USART_INTFLAG_RXC_Pos;
 c30:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_RXC_bit(hw)) {
 c32:	075b      	lsls	r3, r3, #29
 c34:	d515      	bpl.n	c62 <SERCOM0_Handler+0x52>
	SERCOM_CRITICAL_SECTION_LEAVE();
}

static inline hri_sercomusart_status_reg_t hri_sercomusart_read_STATUS_reg(const void *const hw)
{
	return ((Sercom *)hw)->USART.STATUS.reg;
 c36:	8b62      	ldrh	r2, [r4, #26]
		if (hri_sercomusart_read_STATUS_reg(hw)
 c38:	2337      	movs	r3, #55	; 0x37
 c3a:	421a      	tst	r2, r3
 c3c:	d00c      	beq.n	c58 <SERCOM0_Handler+0x48>
	((Sercom *)hw)->USART.STATUS.reg = mask;
 c3e:	3348      	adds	r3, #72	; 0x48
 c40:	8363      	strh	r3, [r4, #26]
}
 c42:	bd10      	pop	{r4, pc}
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_DRE;
 c44:	2301      	movs	r3, #1
 c46:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_byte_sent(device);
 c48:	6803      	ldr	r3, [r0, #0]
 c4a:	4798      	blx	r3
 c4c:	e7f9      	b.n	c42 <SERCOM0_Handler+0x32>
	((Sercom *)hw)->USART.INTENCLR.reg = SERCOM_USART_INTENSET_TXC;
 c4e:	2302      	movs	r3, #2
 c50:	7523      	strb	r3, [r4, #20]
		device->usart_cb.tx_done_cb(device);
 c52:	6883      	ldr	r3, [r0, #8]
 c54:	4798      	blx	r3
 c56:	e7f4      	b.n	c42 <SERCOM0_Handler+0x32>
	return ((Sercom *)hw)->USART.DATA.reg;
 c58:	8d21      	ldrh	r1, [r4, #40]	; 0x28
		device->usart_cb.rx_done_cb(device, hri_sercomusart_read_DATA_reg(hw));
 c5a:	b2c9      	uxtb	r1, r1
 c5c:	6843      	ldr	r3, [r0, #4]
 c5e:	4798      	blx	r3
 c60:	e7ef      	b.n	c42 <SERCOM0_Handler+0x32>
	return (((Sercom *)hw)->USART.INTFLAG.reg & SERCOM_USART_INTFLAG_ERROR) >> SERCOM_USART_INTFLAG_ERROR_Pos;
 c62:	7e23      	ldrb	r3, [r4, #24]
	} else if (hri_sercomusart_get_interrupt_ERROR_bit(hw)) {
 c64:	09db      	lsrs	r3, r3, #7
 c66:	d0ec      	beq.n	c42 <SERCOM0_Handler+0x32>
	((Sercom *)hw)->USART.INTFLAG.reg = SERCOM_USART_INTFLAG_ERROR;
 c68:	2380      	movs	r3, #128	; 0x80
 c6a:	7623      	strb	r3, [r4, #24]
		device->usart_cb.error_cb(device);
 c6c:	68c3      	ldr	r3, [r0, #12]
 c6e:	4798      	blx	r3
	return ((Sercom *)hw)->USART.STATUS.reg;
 c70:	8b63      	ldrh	r3, [r4, #26]
 c72:	b29b      	uxth	r3, r3
	((Sercom *)hw)->USART.STATUS.reg = mask;
 c74:	8363      	strh	r3, [r4, #26]
}
 c76:	e7e4      	b.n	c42 <SERCOM0_Handler+0x32>
 c78:	20000110 	.word	0x20000110

00000c7c <serial_tx_cb>:
 *
 */
static void serial_tx_cb(const struct usart_async_descriptor *const io_descr)
{
	/* Do Nothing */
}
 c7c:	4770      	bx	lr
	...

00000c80 <serial_rx_cb>:
{
 c80:	b510      	push	{r4, lr}
 c82:	b082      	sub	sp, #8
	count = io_read(&USART_0.io, &ch, 1);
 c84:	2201      	movs	r2, #1
 c86:	466b      	mov	r3, sp
 c88:	1dd9      	adds	r1, r3, #7
 c8a:	481f      	ldr	r0, [pc, #124]	; (d08 <serial_rx_cb+0x88>)
 c8c:	4b1f      	ldr	r3, [pc, #124]	; (d0c <serial_rx_cb+0x8c>)
 c8e:	4798      	blx	r3
 c90:	b2c1      	uxtb	r1, r0
	if (serial_receiving == 0)
 c92:	4b1f      	ldr	r3, [pc, #124]	; (d10 <serial_rx_cb+0x90>)
 c94:	781b      	ldrb	r3, [r3, #0]
 c96:	2b00      	cmp	r3, #0
 c98:	d112      	bne.n	cc0 <serial_rx_cb+0x40>
		if (ch != '\r' && ch != '\n')
 c9a:	466b      	mov	r3, sp
 c9c:	79da      	ldrb	r2, [r3, #7]
 c9e:	2a0d      	cmp	r2, #13
 ca0:	d024      	beq.n	cec <serial_rx_cb+0x6c>
 ca2:	2a0a      	cmp	r2, #10
 ca4:	d022      	beq.n	cec <serial_rx_cb+0x6c>
			serial_receiving = 1;
 ca6:	4b1a      	ldr	r3, [pc, #104]	; (d10 <serial_rx_cb+0x90>)
 ca8:	2001      	movs	r0, #1
 caa:	7018      	strb	r0, [r3, #0]
			serial_received_bytes_counter = 0;
 cac:	2000      	movs	r0, #0
 cae:	7058      	strb	r0, [r3, #1]
			rx_buffer[serial_received_bytes_counter] = ch;
 cb0:	7858      	ldrb	r0, [r3, #1]
 cb2:	1818      	adds	r0, r3, r0
 cb4:	7102      	strb	r2, [r0, #4]
			serial_received_bytes_counter += count;
 cb6:	7858      	ldrb	r0, [r3, #1]
 cb8:	1840      	adds	r0, r0, r1
 cba:	b2c0      	uxtb	r0, r0
 cbc:	7058      	strb	r0, [r3, #1]
 cbe:	e015      	b.n	cec <serial_rx_cb+0x6c>
		rx_buffer[serial_received_bytes_counter] = ch;
 cc0:	4b13      	ldr	r3, [pc, #76]	; (d10 <serial_rx_cb+0x90>)
 cc2:	785a      	ldrb	r2, [r3, #1]
 cc4:	4668      	mov	r0, sp
 cc6:	79c4      	ldrb	r4, [r0, #7]
 cc8:	189a      	adds	r2, r3, r2
 cca:	7114      	strb	r4, [r2, #4]
		serial_received_bytes_counter += count;
 ccc:	7858      	ldrb	r0, [r3, #1]
 cce:	1840      	adds	r0, r0, r1
 cd0:	b2c0      	uxtb	r0, r0
 cd2:	7058      	strb	r0, [r3, #1]
		if (ch == '\r' || ch == '\n')
 cd4:	2c0d      	cmp	r4, #13
 cd6:	d00b      	beq.n	cf0 <serial_rx_cb+0x70>
 cd8:	2c0a      	cmp	r4, #10
 cda:	d009      	beq.n	cf0 <serial_rx_cb+0x70>
		if (serial_received_bytes_counter >= SERIAL_BUFFER_SIZE)
 cdc:	4b0c      	ldr	r3, [pc, #48]	; (d10 <serial_rx_cb+0x90>)
 cde:	785b      	ldrb	r3, [r3, #1]
 ce0:	b2db      	uxtb	r3, r3
 ce2:	2bc7      	cmp	r3, #199	; 0xc7
 ce4:	d902      	bls.n	cec <serial_rx_cb+0x6c>
			serial_received_bytes_counter = 0;
 ce6:	2200      	movs	r2, #0
 ce8:	4b09      	ldr	r3, [pc, #36]	; (d10 <serial_rx_cb+0x90>)
 cea:	705a      	strb	r2, [r3, #1]
}
 cec:	b002      	add	sp, #8
 cee:	bd10      	pop	{r4, pc}
			serial_complete = 1;
 cf0:	4a08      	ldr	r2, [pc, #32]	; (d14 <serial_rx_cb+0x94>)
 cf2:	2101      	movs	r1, #1
 cf4:	234c      	movs	r3, #76	; 0x4c
 cf6:	54d1      	strb	r1, [r2, r3]
			total_bytes = serial_received_bytes_counter - 2;
 cf8:	4b05      	ldr	r3, [pc, #20]	; (d10 <serial_rx_cb+0x90>)
 cfa:	785b      	ldrb	r3, [r3, #1]
 cfc:	3b02      	subs	r3, #2
 cfe:	b2db      	uxtb	r3, r3
 d00:	314c      	adds	r1, #76	; 0x4c
 d02:	5453      	strb	r3, [r2, r1]
 d04:	e7ea      	b.n	cdc <serial_rx_cb+0x5c>
 d06:	46c0      	nop			; (mov r8, r8)
 d08:	200001e4 	.word	0x200001e4
 d0c:	000003a9 	.word	0x000003a9
 d10:	20000114 	.word	0x20000114
 d14:	20000194 	.word	0x20000194

00000d18 <main>:

int main(void)
{
 d18:	b5f0      	push	{r4, r5, r6, r7, lr}
 d1a:	b083      	sub	sp, #12
	/* Initializes MCU, drivers and middleware */
	atmel_start_init();
 d1c:	4b1a      	ldr	r3, [pc, #104]	; (d88 <main+0x70>)
 d1e:	4798      	blx	r3
	
	// Initialise ASYNC Driver
	usart_async_register_callback(&USART_0, USART_ASYNC_TXC_CB, serial_tx_cb);
 d20:	4c1a      	ldr	r4, [pc, #104]	; (d8c <main+0x74>)
 d22:	4a1b      	ldr	r2, [pc, #108]	; (d90 <main+0x78>)
 d24:	2101      	movs	r1, #1
 d26:	0020      	movs	r0, r4
 d28:	4d1a      	ldr	r5, [pc, #104]	; (d94 <main+0x7c>)
 d2a:	47a8      	blx	r5
	usart_async_register_callback(&USART_0, USART_ASYNC_RXC_CB, serial_rx_cb);
 d2c:	4a1a      	ldr	r2, [pc, #104]	; (d98 <main+0x80>)
 d2e:	2100      	movs	r1, #0
 d30:	0020      	movs	r0, r4
 d32:	47a8      	blx	r5
	usart_async_enable(&USART_0);
 d34:	0020      	movs	r0, r4
 d36:	4b19      	ldr	r3, [pc, #100]	; (d9c <main+0x84>)
 d38:	4798      	blx	r3

	/* Replace with your application code */
	while (1)
	{
		// Check if we're receiving
		if (serial_receiving == 1)
 d3a:	4f19      	ldr	r7, [pc, #100]	; (da0 <main+0x88>)
		{
			// Check if we're complete
			if (serial_complete == 1)
 d3c:	4e19      	ldr	r6, [pc, #100]	; (da4 <main+0x8c>)
			{
				// Reset Flags
				serial_receiving = 0;
 d3e:	003d      	movs	r5, r7
				serial_complete = 0;
				
				// Copy Message to TX Buffer
				memcpy(&tx_buffer[14], &rx_buffer[0], SERIAL_BUFFER_SIZE);
 d40:	4b19      	ldr	r3, [pc, #100]	; (da8 <main+0x90>)
 d42:	330e      	adds	r3, #14
 d44:	9301      	str	r3, [sp, #4]
 d46:	1d3b      	adds	r3, r7, #4
 d48:	9300      	str	r3, [sp, #0]
			if (serial_complete == 1)
 d4a:	224c      	movs	r2, #76	; 0x4c
		if (serial_receiving == 1)
 d4c:	783b      	ldrb	r3, [r7, #0]
 d4e:	2b01      	cmp	r3, #1
 d50:	d1fc      	bne.n	d4c <main+0x34>
			if (serial_complete == 1)
 d52:	5cb3      	ldrb	r3, [r6, r2]
 d54:	2b01      	cmp	r3, #1
 d56:	d1f9      	bne.n	d4c <main+0x34>
				serial_receiving = 0;
 d58:	2300      	movs	r3, #0
 d5a:	702b      	strb	r3, [r5, #0]
				serial_complete = 0;
 d5c:	4c11      	ldr	r4, [pc, #68]	; (da4 <main+0x8c>)
 d5e:	224c      	movs	r2, #76	; 0x4c
 d60:	54a3      	strb	r3, [r4, r2]
				memcpy(&tx_buffer[14], &rx_buffer[0], SERIAL_BUFFER_SIZE);
 d62:	327c      	adds	r2, #124	; 0x7c
 d64:	9900      	ldr	r1, [sp, #0]
 d66:	9801      	ldr	r0, [sp, #4]
 d68:	4b10      	ldr	r3, [pc, #64]	; (dac <main+0x94>)
 d6a:	4798      	blx	r3
				
				// Print a Message
				io_write(&USART_0.io, tx_buffer, total_bytes + 16);
 d6c:	234d      	movs	r3, #77	; 0x4d
 d6e:	5ce2      	ldrb	r2, [r4, r3]
 d70:	3210      	adds	r2, #16
 d72:	490d      	ldr	r1, [pc, #52]	; (da8 <main+0x90>)
 d74:	4805      	ldr	r0, [pc, #20]	; (d8c <main+0x74>)
 d76:	4b0e      	ldr	r3, [pc, #56]	; (db0 <main+0x98>)
 d78:	4798      	blx	r3
				
				// Clear Memory
				memset(&rx_buffer, 0x00, SERIAL_BUFFER_SIZE);
 d7a:	22c8      	movs	r2, #200	; 0xc8
 d7c:	2100      	movs	r1, #0
 d7e:	9800      	ldr	r0, [sp, #0]
 d80:	4b0c      	ldr	r3, [pc, #48]	; (db4 <main+0x9c>)
 d82:	4798      	blx	r3
 d84:	e7e1      	b.n	d4a <main+0x32>
 d86:	46c0      	nop			; (mov r8, r8)
 d88:	0000011d 	.word	0x0000011d
 d8c:	200001e4 	.word	0x200001e4
 d90:	00000c7d 	.word	0x00000c7d
 d94:	00000665 	.word	0x00000665
 d98:	00000c81 	.word	0x00000c81
 d9c:	00000639 	.word	0x00000639
 da0:	20000114 	.word	0x20000114
 da4:	20000194 	.word	0x20000194
 da8:	20000000 	.word	0x20000000
 dac:	00000e55 	.word	0x00000e55
 db0:	00000375 	.word	0x00000375
 db4:	00000e67 	.word	0x00000e67

00000db8 <__ffssi2>:
 db8:	b510      	push	{r4, lr}
 dba:	2300      	movs	r3, #0
 dbc:	2800      	cmp	r0, #0
 dbe:	d002      	beq.n	dc6 <__ffssi2+0xe>
 dc0:	f000 f804 	bl	dcc <__ctzsi2>
 dc4:	1c43      	adds	r3, r0, #1
 dc6:	0018      	movs	r0, r3
 dc8:	bd10      	pop	{r4, pc}
 dca:	46c0      	nop			; (mov r8, r8)

00000dcc <__ctzsi2>:
 dcc:	4241      	negs	r1, r0
 dce:	4008      	ands	r0, r1
 dd0:	211c      	movs	r1, #28
 dd2:	2301      	movs	r3, #1
 dd4:	041b      	lsls	r3, r3, #16
 dd6:	4298      	cmp	r0, r3
 dd8:	d301      	bcc.n	dde <__ctzsi2+0x12>
 dda:	0c00      	lsrs	r0, r0, #16
 ddc:	3910      	subs	r1, #16
 dde:	0a1b      	lsrs	r3, r3, #8
 de0:	4298      	cmp	r0, r3
 de2:	d301      	bcc.n	de8 <__ctzsi2+0x1c>
 de4:	0a00      	lsrs	r0, r0, #8
 de6:	3908      	subs	r1, #8
 de8:	091b      	lsrs	r3, r3, #4
 dea:	4298      	cmp	r0, r3
 dec:	d301      	bcc.n	df2 <__ctzsi2+0x26>
 dee:	0900      	lsrs	r0, r0, #4
 df0:	3904      	subs	r1, #4
 df2:	a202      	add	r2, pc, #8	; (adr r2, dfc <__ctzsi2+0x30>)
 df4:	5c10      	ldrb	r0, [r2, r0]
 df6:	1a40      	subs	r0, r0, r1
 df8:	4770      	bx	lr
 dfa:	46c0      	nop			; (mov r8, r8)
 dfc:	1d1d1c1b 	.word	0x1d1d1c1b
 e00:	1e1e1e1e 	.word	0x1e1e1e1e
 e04:	1f1f1f1f 	.word	0x1f1f1f1f
 e08:	1f1f1f1f 	.word	0x1f1f1f1f

00000e0c <__libc_init_array>:
 e0c:	b570      	push	{r4, r5, r6, lr}
 e0e:	2600      	movs	r6, #0
 e10:	4d0c      	ldr	r5, [pc, #48]	; (e44 <__libc_init_array+0x38>)
 e12:	4c0d      	ldr	r4, [pc, #52]	; (e48 <__libc_init_array+0x3c>)
 e14:	1b64      	subs	r4, r4, r5
 e16:	10a4      	asrs	r4, r4, #2
 e18:	42a6      	cmp	r6, r4
 e1a:	d109      	bne.n	e30 <__libc_init_array+0x24>
 e1c:	2600      	movs	r6, #0
 e1e:	f000 f875 	bl	f0c <_init>
 e22:	4d0a      	ldr	r5, [pc, #40]	; (e4c <__libc_init_array+0x40>)
 e24:	4c0a      	ldr	r4, [pc, #40]	; (e50 <__libc_init_array+0x44>)
 e26:	1b64      	subs	r4, r4, r5
 e28:	10a4      	asrs	r4, r4, #2
 e2a:	42a6      	cmp	r6, r4
 e2c:	d105      	bne.n	e3a <__libc_init_array+0x2e>
 e2e:	bd70      	pop	{r4, r5, r6, pc}
 e30:	00b3      	lsls	r3, r6, #2
 e32:	58eb      	ldr	r3, [r5, r3]
 e34:	4798      	blx	r3
 e36:	3601      	adds	r6, #1
 e38:	e7ee      	b.n	e18 <__libc_init_array+0xc>
 e3a:	00b3      	lsls	r3, r6, #2
 e3c:	58eb      	ldr	r3, [r5, r3]
 e3e:	4798      	blx	r3
 e40:	3601      	adds	r6, #1
 e42:	e7f2      	b.n	e2a <__libc_init_array+0x1e>
 e44:	00000f18 	.word	0x00000f18
 e48:	00000f18 	.word	0x00000f18
 e4c:	00000f18 	.word	0x00000f18
 e50:	00000f1c 	.word	0x00000f1c

00000e54 <memcpy>:
 e54:	2300      	movs	r3, #0
 e56:	b510      	push	{r4, lr}
 e58:	429a      	cmp	r2, r3
 e5a:	d100      	bne.n	e5e <memcpy+0xa>
 e5c:	bd10      	pop	{r4, pc}
 e5e:	5ccc      	ldrb	r4, [r1, r3]
 e60:	54c4      	strb	r4, [r0, r3]
 e62:	3301      	adds	r3, #1
 e64:	e7f8      	b.n	e58 <memcpy+0x4>

00000e66 <memset>:
 e66:	0003      	movs	r3, r0
 e68:	1882      	adds	r2, r0, r2
 e6a:	4293      	cmp	r3, r2
 e6c:	d100      	bne.n	e70 <memset+0xa>
 e6e:	4770      	bx	lr
 e70:	7019      	strb	r1, [r3, #0]
 e72:	3301      	adds	r3, #1
 e74:	e7f9      	b.n	e6a <memset+0x4>
 e76:	0000      	movs	r0, r0
 e78:	682f2e2e 	.word	0x682f2e2e
 e7c:	732f6c61 	.word	0x732f6c61
 e80:	682f6372 	.word	0x682f6372
 e84:	695f6c61 	.word	0x695f6c61
 e88:	00632e6f 	.word	0x00632e6f
 e8c:	682f2e2e 	.word	0x682f2e2e
 e90:	732f6c61 	.word	0x732f6c61
 e94:	682f6372 	.word	0x682f6372
 e98:	755f6c61 	.word	0x755f6c61
 e9c:	74726173 	.word	0x74726173
 ea0:	7973615f 	.word	0x7973615f
 ea4:	632e636e 	.word	0x632e636e
 ea8:	00000000 	.word	0x00000000
 eac:	682f2e2e 	.word	0x682f2e2e
 eb0:	752f6c61 	.word	0x752f6c61
 eb4:	736c6974 	.word	0x736c6974
 eb8:	6372732f 	.word	0x6372732f
 ebc:	6974752f 	.word	0x6974752f
 ec0:	725f736c 	.word	0x725f736c
 ec4:	62676e69 	.word	0x62676e69
 ec8:	65666675 	.word	0x65666675
 ecc:	00632e72 	.word	0x00632e72

00000ed0 <_map>:
 ed0:	00000008 0000001c 682f2e2e 652f6c70     ........../hpl/e
 ee0:	682f6369 655f6c70 632e6369 00000000     ic/hpl_eic.c....
 ef0:	682f2e2e 732f6c70 6f637265 70682f6d     ../hpl/sercom/hp
 f00:	65735f6c 6d6f6372 0000632e              l_sercom.c..

00000f0c <_init>:
 f0c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 f0e:	46c0      	nop			; (mov r8, r8)
 f10:	bcf8      	pop	{r3, r4, r5, r6, r7}
 f12:	bc08      	pop	{r3}
 f14:	469e      	mov	lr, r3
 f16:	4770      	bx	lr

00000f18 <__init_array_start>:
 f18:	000000e5 	.word	0x000000e5

00000f1c <_fini>:
 f1c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 f1e:	46c0      	nop			; (mov r8, r8)
 f20:	bcf8      	pop	{r3, r4, r5, r6, r7}
 f22:	bc08      	pop	{r3}
 f24:	469e      	mov	lr, r3
 f26:	4770      	bx	lr

00000f28 <__fini_array_start>:
 f28:	000000bd 	.word	0x000000bd
